// automatically generated by rust-bindgen 0.70.1

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CRYPT_LOG_NORMAL: u32 = 0;
pub const CRYPT_LOG_ERROR: u32 = 1;
pub const CRYPT_LOG_VERBOSE: u32 = 2;
pub const CRYPT_LOG_DEBUG: i32 = -1;
pub const CRYPT_LOG_DEBUG_JSON: i32 = -2;
pub const CRYPT_RNG_URANDOM: u32 = 0;
pub const CRYPT_RNG_RANDOM: u32 = 1;
pub const CRYPT_KDF_PBKDF2: &[u8; 7] = b"pbkdf2\0";
pub const CRYPT_KDF_ARGON2I: &[u8; 8] = b"argon2i\0";
pub const CRYPT_KDF_ARGON2ID: &[u8; 9] = b"argon2id\0";
pub const CRYPT_PLAIN: &[u8; 6] = b"PLAIN\0";
pub const CRYPT_LUKS1: &[u8; 6] = b"LUKS1\0";
pub const CRYPT_LUKS2: &[u8; 6] = b"LUKS2\0";
pub const CRYPT_LOOPAES: &[u8; 8] = b"LOOPAES\0";
pub const CRYPT_VERITY: &[u8; 7] = b"VERITY\0";
pub const CRYPT_TCRYPT: &[u8; 7] = b"TCRYPT\0";
pub const CRYPT_INTEGRITY: &[u8; 10] = b"INTEGRITY\0";
pub const CRYPT_BITLK: &[u8; 6] = b"BITLK\0";
pub const CRYPT_FVAULT2: &[u8; 8] = b"FVAULT2\0";
pub const CRYPT_ANY_SLOT: i32 = -1;
pub const CRYPT_DEBUG_ALL: i32 = -1;
pub const CRYPT_DEBUG_JSON: i32 = -2;
pub const CRYPT_DEBUG_NONE: u32 = 0;
pub const CRYPT_ANY_TOKEN: i32 = -1;
pub const CRYPT_TOKEN_ABI_VERSION1: &[u8; 21] = b"CRYPTSETUP_TOKEN_1.0\0";
pub const CRYPT_TOKEN_ABI_OPEN: &[u8; 22] = b"cryptsetup_token_open\0";
pub const CRYPT_TOKEN_ABI_OPEN_PIN: &[u8; 26] = b"cryptsetup_token_open_pin\0";
pub const CRYPT_TOKEN_ABI_BUFFER_FREE: &[u8; 29] = b"cryptsetup_token_buffer_free\0";
pub const CRYPT_TOKEN_ABI_VALIDATE: &[u8; 26] = b"cryptsetup_token_validate\0";
pub const CRYPT_TOKEN_ABI_DUMP: &[u8; 22] = b"cryptsetup_token_dump\0";
pub const CRYPT_TOKEN_ABI_VERSION: &[u8; 25] = b"cryptsetup_token_version\0";
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
/// @defgroup crypt-init Cryptsetup device context initialization
/// Set of functions for creating and destroying @e crypt_device context
/// @addtogroup crypt-init
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_keyslot_context {
    _unused: [u8; 0],
}
extern "C" {
    /// Initialize crypt device handle and check if the provided device exists.
    ///
    /// @param cd Returns pointer to crypt device handle
    /// @param device Path to the backing device.
    /// 	  If @e device is not a block device but a path to some file,
    /// 	  the function will try to create a loopdevice and attach
    /// 	  the file to the loopdevice with AUTOCLEAR flag set.
    /// 	  If @e device is @e NULL function it will initialize dm backend only.
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note Note that logging is not initialized here, possible messages use
    /// 	 default log function.
    pub fn crypt_init(
        cd: *mut *mut crypt_device,
        device: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize crypt device handle with optional data device and check
    /// if devices exist.
    ///
    /// @param cd Returns pointer to crypt device handle
    /// @param device Path to the backing device or detached header.
    /// @param data_device Path to the data device or @e NULL.
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note Note that logging is not initialized here, possible messages use
    /// 	 default log function.
    pub fn crypt_init_data_device(
        cd: *mut *mut crypt_device,
        device: *const ::std::os::raw::c_char,
        data_device: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize crypt device handle from provided active device name,
    /// and, optionally, from separate metadata (header) device
    /// and check if provided device exists.
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @param cd returns crypt device handle for active device
    /// @param name name of active crypt device
    /// @param header_device optional device containing on-disk header
    /// 	  (@e NULL if it the same as underlying device on there is no on-disk
    /// header)
    ///
    /// @post In case @e device points to active LUKS device but header load
    /// fails, context device type is set to @e NULL and @e 0 is returned as
    /// if it were successful. Context with @e NULL device type can only be
    /// deactivated by crypt_deactivate
    ///
    /// @note @link crypt_init_by_name @endlink is equivalent to calling
    /// 	 crypt_init_by_name_and_header(cd, name, NULL);
    pub fn crypt_init_by_name_and_header(
        cd: *mut *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        header_device: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This is equivalent to call
    /// @ref crypt_init_by_name_and_header "crypt_init_by_name_and_header(cd,
    /// name, NULL)"
    ///
    /// @sa crypt_init_by_name_and_header
    pub fn crypt_init_by_name(
        cd: *mut *mut crypt_device,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Release crypt device context and used memory.
    ///
    /// @param cd crypt device handle
    pub fn crypt_free(cd: *mut crypt_device);
}
extern "C" {
    /// Set confirmation callback (yes/no).
    ///
    /// If code need confirmation (like resetting uuid or restoring LUKS header
    /// from file) this function is called. If not defined, everything is
    /// confirmed.
    ///
    /// Callback function @e confirm should return @e 0 if operation is
    /// declined, other values mean accepted.
    ///
    /// @param cd crypt device handle
    /// @param confirm user defined confirm callback reference; use
    ///        @p msg for message for user to confirm and
    ///        @p usrptr for identification in callback
    /// @param usrptr provided identification in callback
    ///
    /// @note Current version of cryptsetup API requires confirmation for UUID
    /// change and 	 LUKS header restore only.
    pub fn crypt_set_confirm_callback(
        cd: *mut crypt_device,
        confirm: ::std::option::Option<
            unsafe extern "C" fn(
                msg: *const ::std::os::raw::c_char,
                usrptr: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        usrptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Set data device
    /// For LUKS it is encrypted data device when LUKS header is separated.
    /// For VERITY it is data device when hash device is separated.
    ///
    /// @param cd crypt device handle
    /// @param device path to device
    ///
    /// @returns 0 on success or negative errno value otherwise.
    pub fn crypt_set_data_device(
        cd: *mut crypt_device,
        device: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set data device offset in 512-byte sectors.
    /// Used for LUKS.
    /// This function is replacement for data alignment fields in LUKS param
    /// struct. If set to 0 (default), old behaviour is preserved.
    /// This value is reset on @link crypt_load @endlink.
    ///
    /// @param cd crypt device handle
    /// @param data_offset data offset in bytes
    ///
    /// @returns 0 on success or negative errno value otherwise.
    ///
    /// @note Data offset must be aligned to multiple of 8 (alignment to
    /// 4096-byte sectors) and must be big enough to accommodate the whole
    /// LUKS header with all keyslots. @note Data offset is enforced by this
    /// function, device topology information is no longer used after
    /// calling this function.
    pub fn crypt_set_data_offset(cd: *mut crypt_device, data_offset: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set log function.
    ///
    /// @param cd crypt device handle (can be @e NULL to set default log
    /// function) @param log user defined log function reference; use
    ///        @p level for log level,
    ///        @p msg for message, and
    ///        @p usrptr for identification in callback
    /// @param usrptr provided identification in callback
    pub fn crypt_set_log_callback(
        cd: *mut crypt_device,
        log: ::std::option::Option<
            unsafe extern "C" fn(
                level: ::std::os::raw::c_int,
                msg: *const ::std::os::raw::c_char,
                usrptr: *mut ::std::os::raw::c_void,
            ),
        >,
        usrptr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    /// Defines log function or use the default one otherwise.
    ///
    /// @see crypt_set_log_callback
    ///
    /// @param cd crypt device handle
    /// @param level log level
    /// @param msg log message
    pub fn crypt_log(
        cd: *mut crypt_device,
        level: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// Log function with variable arguments.
    ///
    /// @param cd crypt device handle
    /// @param level log level
    /// @param format formatted log message
    pub fn crypt_logf(
        cd: *mut crypt_device,
        level: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    /// Set which RNG (random number generator) is used for generating long term
    /// key
    ///
    /// @param cd crypt device handle
    /// @param rng_type kernel random number generator to use
    pub fn crypt_set_rng_type(cd: *mut crypt_device, rng_type: ::std::os::raw::c_int);
}
extern "C" {
    /// Get which RNG (random number generator) is used for generating long term
    /// key.
    ///
    /// @param cd crypt device handle
    /// @return RNG type on success or negative errno value otherwise.
    pub fn crypt_get_rng_type(cd: *mut crypt_device) -> ::std::os::raw::c_int;
}
/// PBKDF parameters.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_pbkdf_type {
    /// < PBKDF algorithm
    pub type_: *const ::std::os::raw::c_char,
    /// < Hash algorithm
    pub hash: *const ::std::os::raw::c_char,
    /// < Requested time cost [milliseconds]
    pub time_ms: u32,
    /// < Iterations, 0 or benchmarked value.
    pub iterations: u32,
    /// < Requested or benchmarked  memory cost [kilobytes]
    pub max_memory_kb: u32,
    /// < Requested parallel cost [threads]
    pub parallel_threads: u32,
    /// < CRYPT_PBKDF* flags
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_pbkdf_type"][::std::mem::size_of::<crypt_pbkdf_type>() - 40usize];
    ["Alignment of crypt_pbkdf_type"][::std::mem::align_of::<crypt_pbkdf_type>() - 8usize];
    ["Offset of field: crypt_pbkdf_type::type_"]
        [::std::mem::offset_of!(crypt_pbkdf_type, type_) - 0usize];
    ["Offset of field: crypt_pbkdf_type::hash"]
        [::std::mem::offset_of!(crypt_pbkdf_type, hash) - 8usize];
    ["Offset of field: crypt_pbkdf_type::time_ms"]
        [::std::mem::offset_of!(crypt_pbkdf_type, time_ms) - 16usize];
    ["Offset of field: crypt_pbkdf_type::iterations"]
        [::std::mem::offset_of!(crypt_pbkdf_type, iterations) - 20usize];
    ["Offset of field: crypt_pbkdf_type::max_memory_kb"]
        [::std::mem::offset_of!(crypt_pbkdf_type, max_memory_kb) - 24usize];
    ["Offset of field: crypt_pbkdf_type::parallel_threads"]
        [::std::mem::offset_of!(crypt_pbkdf_type, parallel_threads) - 28usize];
    ["Offset of field: crypt_pbkdf_type::flags"]
        [::std::mem::offset_of!(crypt_pbkdf_type, flags) - 32usize];
};
extern "C" {
    /// Set default PBKDF (Password-Based Key Derivation Algorithm) for next
    /// keyslot about to get created with any crypt_keyslot_add_*() call.
    ///
    /// @param cd crypt device handle
    /// @param pbkdf PBKDF parameters
    ///
    /// @return 0 on success or negative errno value otherwise.
    ///
    /// @note For LUKS1, only PBKDF2 is supported, other settings will be
    /// rejected. @note For non-LUKS context types the call succeeds, but
    /// PBKDF is not used.
    pub fn crypt_set_pbkdf_type(
        cd: *mut crypt_device,
        pbkdf: *const crypt_pbkdf_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get PBKDF (Password-Based Key Derivation Algorithm) parameters.
    ///
    /// @param pbkdf_type type of PBKDF
    ///
    /// @return struct on success or NULL value otherwise.
    pub fn crypt_get_pbkdf_type_params(
        pbkdf_type: *const ::std::os::raw::c_char,
    ) -> *const crypt_pbkdf_type;
}
extern "C" {
    /// Get default PBKDF (Password-Based Key Derivation Algorithm) settings for
    /// keyslots. Works only with LUKS device handles (both versions).
    ///
    /// @param type type of device (see @link crypt-type @endlink)
    ///
    /// @return struct on success or NULL value otherwise.
    pub fn crypt_get_pbkdf_default(type_: *const ::std::os::raw::c_char)
        -> *const crypt_pbkdf_type;
}
extern "C" {
    /// Get current PBKDF (Password-Based Key Derivation Algorithm) settings for
    /// keyslots. Works only with LUKS device handles (both versions).
    ///
    /// @param cd crypt device handle
    ///
    /// @return struct on success or NULL value otherwise.
    pub fn crypt_get_pbkdf_type(cd: *mut crypt_device) -> *const crypt_pbkdf_type;
}
extern "C" {
    /// Set how long should cryptsetup iterate in PBKDF2 function.
    /// Default value heads towards the iterations which takes around 1 second.
    /// \b Deprecated, only for backward compatibility.
    /// Use @link crypt_set_pbkdf_type @endlink.
    ///
    /// @param cd crypt device handle
    /// @param iteration_time_ms the time in ms
    ///
    /// @note If the time value is not acceptable for active PBKDF, value is
    /// quietly ignored.
    pub fn crypt_set_iteration_time(cd: *mut crypt_device, iteration_time_ms: u64);
}
extern "C" {
    /// Helper to lock/unlock memory to avoid swap sensitive data to disk.
    /// \b Deprecated, only for backward compatibility. Memory with keys are
    /// locked automatically.
    ///
    /// @param cd crypt device handle, can be @e NULL
    /// @param lock 0 to unlock otherwise lock memory
    ///
    /// @returns Value indicating whether the memory is locked (function can be
    /// called multiple times).
    ///
    /// @note Only root can do this.
    /// @note It locks/unlocks all process memory, not only crypt context.
    pub fn crypt_memory_lock(
        cd: *mut crypt_device,
        lock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set global lock protection for on-disk metadata (file-based locking).
    ///
    /// @param cd crypt device handle, can be @e NULL
    /// @param enable 0 to disable locking otherwise enable it (default)
    ///
    /// @returns @e 0 on success or negative errno value otherwise.
    ///
    /// @note Locking applied only for some metadata formats (LUKS2).
    /// @note The switch is global on the library level.
    /// 	 In current version locking can be only switched off and cannot be
    /// switched on later.
    pub fn crypt_metadata_locking(
        cd: *mut crypt_device,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set metadata header area sizes. This applies only to LUKS2.
    /// These values limit amount of metadata anf number of supportable
    /// keyslots.
    ///
    /// @param cd crypt device handle, can be @e NULL
    /// @param metadata_size size in bytes of JSON area + 4k binary header
    /// @param keyslots_size size in bytes of binary keyslots area
    ///
    /// @returns @e 0 on success or negative errno value otherwise.
    ///
    /// @note The metadata area is stored twice and both copies contain 4k
    /// binary header. Only 16,32,64,128,256,512,1024,2048 and 4096 kB value
    /// is allowed (see LUKS2 specification). @note Keyslots area size must
    /// be multiple of 4k with maximum 128MB.
    pub fn crypt_set_metadata_size(
        cd: *mut crypt_device,
        metadata_size: u64,
        keyslots_size: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get metadata header area sizes. This applies only to LUKS2.
    /// These values limit amount of metadata anf number of supportable
    /// keyslots.
    ///
    /// @param cd crypt device handle
    /// @param metadata_size size in bytes of JSON area + 4k binary header
    /// @param keyslots_size size in bytes of binary keyslots area
    ///
    /// @returns @e 0 on success or negative errno value otherwise.
    pub fn crypt_get_metadata_size(
        cd: *mut crypt_device,
        metadata_size: *mut u64,
        keyslots_size: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get device type
    ///
    /// @param cd crypt device handle
    /// @return string according to device type or @e NULL if not known.
    pub fn crypt_get_type(cd: *mut crypt_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get device default LUKS type
    ///
    /// @return string according to device type (CRYPT_LUKS1 or CRYPT_LUKS2).
    pub fn crypt_get_default_type() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get HW encryption type
    ///
    /// @return HW encryption type (see @link crypt-hw-encryption-types
    /// @endlink)         or negative errno otherwise.
    pub fn crypt_get_hw_encryption_type(cd: *mut crypt_device) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get HW encryption (like OPAL) key size (in bytes)
    ///
    /// @return key size or 0 if no HW encryption is used.
    pub fn crypt_get_hw_encryption_key_size(cd: *mut crypt_device) -> ::std::os::raw::c_int;
}
/// Structure used as parameter for PLAIN device type.
///
/// @see crypt_format
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_plain {
    /// < password hash function
    pub hash: *const ::std::os::raw::c_char,
    /// < offset in sectors
    pub offset: u64,
    /// < IV offset / initialization sector
    pub skip: u64,
    /// < size of mapped device or @e 0 for autodetection
    pub size: u64,
    /// < sector size in bytes (@e 0 means 512 for compatibility)
    pub sector_size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_plain"][::std::mem::size_of::<crypt_params_plain>() - 40usize];
    ["Alignment of crypt_params_plain"][::std::mem::align_of::<crypt_params_plain>() - 8usize];
    ["Offset of field: crypt_params_plain::hash"]
        [::std::mem::offset_of!(crypt_params_plain, hash) - 0usize];
    ["Offset of field: crypt_params_plain::offset"]
        [::std::mem::offset_of!(crypt_params_plain, offset) - 8usize];
    ["Offset of field: crypt_params_plain::skip"]
        [::std::mem::offset_of!(crypt_params_plain, skip) - 16usize];
    ["Offset of field: crypt_params_plain::size"]
        [::std::mem::offset_of!(crypt_params_plain, size) - 24usize];
    ["Offset of field: crypt_params_plain::sector_size"]
        [::std::mem::offset_of!(crypt_params_plain, sector_size) - 32usize];
};
/// Structure used as parameter for LUKS device type.
///
/// @see crypt_format, crypt_load
///
/// @note during crypt_format @e data_device attribute determines
/// 	 if the LUKS header is separated from encrypted payload device
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_luks1 {
    /// < hash used in LUKS header
    pub hash: *const ::std::os::raw::c_char,
    /// < data area alignment in 512B sectors, data offset is multiple of this
    pub data_alignment: usize,
    /// < detached encrypted data device or @e NULL
    pub data_device: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_luks1"][::std::mem::size_of::<crypt_params_luks1>() - 24usize];
    ["Alignment of crypt_params_luks1"][::std::mem::align_of::<crypt_params_luks1>() - 8usize];
    ["Offset of field: crypt_params_luks1::hash"]
        [::std::mem::offset_of!(crypt_params_luks1, hash) - 0usize];
    ["Offset of field: crypt_params_luks1::data_alignment"]
        [::std::mem::offset_of!(crypt_params_luks1, data_alignment) - 8usize];
    ["Offset of field: crypt_params_luks1::data_device"]
        [::std::mem::offset_of!(crypt_params_luks1, data_device) - 16usize];
};
/// Structure used as parameter for loop-AES device type.
///
/// @see crypt_format
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_loopaes {
    /// < key hash function
    pub hash: *const ::std::os::raw::c_char,
    /// < offset in sectors
    pub offset: u64,
    /// < IV offset / initialization sector
    pub skip: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_loopaes"][::std::mem::size_of::<crypt_params_loopaes>() - 24usize];
    ["Alignment of crypt_params_loopaes"][::std::mem::align_of::<crypt_params_loopaes>() - 8usize];
    ["Offset of field: crypt_params_loopaes::hash"]
        [::std::mem::offset_of!(crypt_params_loopaes, hash) - 0usize];
    ["Offset of field: crypt_params_loopaes::offset"]
        [::std::mem::offset_of!(crypt_params_loopaes, offset) - 8usize];
    ["Offset of field: crypt_params_loopaes::skip"]
        [::std::mem::offset_of!(crypt_params_loopaes, skip) - 16usize];
};
/// Structure used as parameter for dm-verity device type.
///
/// @see crypt_format, crypt_load
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_verity {
    /// < hash function
    pub hash_name: *const ::std::os::raw::c_char,
    /// < data_device (CRYPT_VERITY_CREATE_HASH)
    pub data_device: *const ::std::os::raw::c_char,
    /// < hash_device (output only)
    pub hash_device: *const ::std::os::raw::c_char,
    /// < fec_device (output only)
    pub fec_device: *const ::std::os::raw::c_char,
    /// < salt
    pub salt: *const ::std::os::raw::c_char,
    /// < salt size (in bytes)
    pub salt_size: u32,
    /// < in-kernel hashing type
    pub hash_type: u32,
    /// < data block size (in bytes)
    pub data_block_size: u32,
    /// < hash block size (in bytes)
    pub hash_block_size: u32,
    /// < data area size (in data blocks)
    pub data_size: u64,
    /// < hash/header offset (in bytes)
    pub hash_area_offset: u64,
    /// < FEC/header offset (in bytes)
    pub fec_area_offset: u64,
    /// < Reed-Solomon FEC roots
    pub fec_roots: u32,
    /// < CRYPT_VERITY* flags
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_verity"][::std::mem::size_of::<crypt_params_verity>() - 88usize];
    ["Alignment of crypt_params_verity"][::std::mem::align_of::<crypt_params_verity>() - 8usize];
    ["Offset of field: crypt_params_verity::hash_name"]
        [::std::mem::offset_of!(crypt_params_verity, hash_name) - 0usize];
    ["Offset of field: crypt_params_verity::data_device"]
        [::std::mem::offset_of!(crypt_params_verity, data_device) - 8usize];
    ["Offset of field: crypt_params_verity::hash_device"]
        [::std::mem::offset_of!(crypt_params_verity, hash_device) - 16usize];
    ["Offset of field: crypt_params_verity::fec_device"]
        [::std::mem::offset_of!(crypt_params_verity, fec_device) - 24usize];
    ["Offset of field: crypt_params_verity::salt"]
        [::std::mem::offset_of!(crypt_params_verity, salt) - 32usize];
    ["Offset of field: crypt_params_verity::salt_size"]
        [::std::mem::offset_of!(crypt_params_verity, salt_size) - 40usize];
    ["Offset of field: crypt_params_verity::hash_type"]
        [::std::mem::offset_of!(crypt_params_verity, hash_type) - 44usize];
    ["Offset of field: crypt_params_verity::data_block_size"]
        [::std::mem::offset_of!(crypt_params_verity, data_block_size) - 48usize];
    ["Offset of field: crypt_params_verity::hash_block_size"]
        [::std::mem::offset_of!(crypt_params_verity, hash_block_size) - 52usize];
    ["Offset of field: crypt_params_verity::data_size"]
        [::std::mem::offset_of!(crypt_params_verity, data_size) - 56usize];
    ["Offset of field: crypt_params_verity::hash_area_offset"]
        [::std::mem::offset_of!(crypt_params_verity, hash_area_offset) - 64usize];
    ["Offset of field: crypt_params_verity::fec_area_offset"]
        [::std::mem::offset_of!(crypt_params_verity, fec_area_offset) - 72usize];
    ["Offset of field: crypt_params_verity::fec_roots"]
        [::std::mem::offset_of!(crypt_params_verity, fec_roots) - 80usize];
    ["Offset of field: crypt_params_verity::flags"]
        [::std::mem::offset_of!(crypt_params_verity, flags) - 84usize];
};
/// Structure used as parameter for TCRYPT device type.
///
/// @see crypt_load
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_tcrypt {
    /// < passphrase to unlock header (input only)
    pub passphrase: *const ::std::os::raw::c_char,
    /// < passphrase size (input only, max length is 64)
    pub passphrase_size: usize,
    /// < keyfile paths to unlock header (input only)
    pub keyfiles: *mut *const ::std::os::raw::c_char,
    /// < keyfiles count (input only)
    pub keyfiles_count: ::std::os::raw::c_uint,
    /// < hash function for PBKDF
    pub hash_name: *const ::std::os::raw::c_char,
    /// < cipher chain c1[-c2[-c3]]
    pub cipher: *const ::std::os::raw::c_char,
    /// < cipher block mode
    pub mode: *const ::std::os::raw::c_char,
    /// < key size in bytes (the whole chain)
    pub key_size: usize,
    /// < CRYPT_TCRYPT* flags
    pub flags: u32,
    /// < VeraCrypt Personal Iteration Multiplier
    pub veracrypt_pim: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_tcrypt"][::std::mem::size_of::<crypt_params_tcrypt>() - 72usize];
    ["Alignment of crypt_params_tcrypt"][::std::mem::align_of::<crypt_params_tcrypt>() - 8usize];
    ["Offset of field: crypt_params_tcrypt::passphrase"]
        [::std::mem::offset_of!(crypt_params_tcrypt, passphrase) - 0usize];
    ["Offset of field: crypt_params_tcrypt::passphrase_size"]
        [::std::mem::offset_of!(crypt_params_tcrypt, passphrase_size) - 8usize];
    ["Offset of field: crypt_params_tcrypt::keyfiles"]
        [::std::mem::offset_of!(crypt_params_tcrypt, keyfiles) - 16usize];
    ["Offset of field: crypt_params_tcrypt::keyfiles_count"]
        [::std::mem::offset_of!(crypt_params_tcrypt, keyfiles_count) - 24usize];
    ["Offset of field: crypt_params_tcrypt::hash_name"]
        [::std::mem::offset_of!(crypt_params_tcrypt, hash_name) - 32usize];
    ["Offset of field: crypt_params_tcrypt::cipher"]
        [::std::mem::offset_of!(crypt_params_tcrypt, cipher) - 40usize];
    ["Offset of field: crypt_params_tcrypt::mode"]
        [::std::mem::offset_of!(crypt_params_tcrypt, mode) - 48usize];
    ["Offset of field: crypt_params_tcrypt::key_size"]
        [::std::mem::offset_of!(crypt_params_tcrypt, key_size) - 56usize];
    ["Offset of field: crypt_params_tcrypt::flags"]
        [::std::mem::offset_of!(crypt_params_tcrypt, flags) - 64usize];
    ["Offset of field: crypt_params_tcrypt::veracrypt_pim"]
        [::std::mem::offset_of!(crypt_params_tcrypt, veracrypt_pim) - 68usize];
};
/// Structure used as parameter for dm-integrity device type.
///
/// @see crypt_format, crypt_load
///
/// @note In bitmap tracking mode, the journal is implicitly disabled.
///       As an ugly workaround for compatibility, journal_watermark is
/// overloaded       to mean 512-bytes sectors-per-bit and journal_commit_time
/// means bitmap flush time.       All other journal parameters are not applied
/// in the bitmap mode.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_integrity {
    /// < size of journal in bytes
    pub journal_size: u64,
    /// < journal flush watermark in percents; in bitmap mode sectors-per-bit
    pub journal_watermark: ::std::os::raw::c_uint,
    /// < journal commit time (or bitmap flush time) in ms
    pub journal_commit_time: ::std::os::raw::c_uint,
    /// < number of interleave sectors (power of two)
    pub interleave_sectors: u32,
    /// < tag size per-sector in bytes
    pub tag_size: u32,
    /// < sector size in bytes
    pub sector_size: u32,
    /// < number of sectors in one buffer
    pub buffer_sectors: u32,
    /// < integrity algorithm, NULL for LUKS2
    pub integrity: *const ::std::os::raw::c_char,
    /// < integrity key size in bytes, info only, 0 for LUKS2
    pub integrity_key_size: u32,
    /// < journal integrity algorithm
    pub journal_integrity: *const ::std::os::raw::c_char,
    /// < journal integrity key, only for crypt_load
    pub journal_integrity_key: *const ::std::os::raw::c_char,
    /// < journal integrity key size in bytes, only for crypt_load
    pub journal_integrity_key_size: u32,
    /// < journal encryption algorithm
    pub journal_crypt: *const ::std::os::raw::c_char,
    /// < journal crypt key, only for crypt_load
    pub journal_crypt_key: *const ::std::os::raw::c_char,
    /// < journal crypt key size in bytes, only for crypt_load
    pub journal_crypt_key_size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_integrity"][::std::mem::size_of::<crypt_params_integrity>() - 96usize];
    ["Alignment of crypt_params_integrity"]
        [::std::mem::align_of::<crypt_params_integrity>() - 8usize];
    ["Offset of field: crypt_params_integrity::journal_size"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_size) - 0usize];
    ["Offset of field: crypt_params_integrity::journal_watermark"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_watermark) - 8usize];
    ["Offset of field: crypt_params_integrity::journal_commit_time"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_commit_time) - 12usize];
    ["Offset of field: crypt_params_integrity::interleave_sectors"]
        [::std::mem::offset_of!(crypt_params_integrity, interleave_sectors) - 16usize];
    ["Offset of field: crypt_params_integrity::tag_size"]
        [::std::mem::offset_of!(crypt_params_integrity, tag_size) - 20usize];
    ["Offset of field: crypt_params_integrity::sector_size"]
        [::std::mem::offset_of!(crypt_params_integrity, sector_size) - 24usize];
    ["Offset of field: crypt_params_integrity::buffer_sectors"]
        [::std::mem::offset_of!(crypt_params_integrity, buffer_sectors) - 28usize];
    ["Offset of field: crypt_params_integrity::integrity"]
        [::std::mem::offset_of!(crypt_params_integrity, integrity) - 32usize];
    ["Offset of field: crypt_params_integrity::integrity_key_size"]
        [::std::mem::offset_of!(crypt_params_integrity, integrity_key_size) - 40usize];
    ["Offset of field: crypt_params_integrity::journal_integrity"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_integrity) - 48usize];
    ["Offset of field: crypt_params_integrity::journal_integrity_key"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_integrity_key) - 56usize];
    ["Offset of field: crypt_params_integrity::journal_integrity_key_size"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_integrity_key_size) - 64usize];
    ["Offset of field: crypt_params_integrity::journal_crypt"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_crypt) - 72usize];
    ["Offset of field: crypt_params_integrity::journal_crypt_key"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_crypt_key) - 80usize];
    ["Offset of field: crypt_params_integrity::journal_crypt_key_size"]
        [::std::mem::offset_of!(crypt_params_integrity, journal_crypt_key_size) - 88usize];
};
/// Structure used as parameter for LUKS2 device type.
///
/// @see crypt_format, crypt_load
///
/// @note during crypt_format @e data_device attribute determines
/// 	 if the LUKS2 header is separated from encrypted payload device
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_luks2 {
    /// < PBKDF (and hash) parameters or @e NULL
    pub pbkdf: *const crypt_pbkdf_type,
    /// < integrity algorithm or @e NULL
    pub integrity: *const ::std::os::raw::c_char,
    /// < Data integrity parameters or @e NULL
    pub integrity_params: *const crypt_params_integrity,
    /// < data area alignment in 512B sectors, data offset is multiple of this
    pub data_alignment: usize,
    /// < detached encrypted data device or @e NULL
    pub data_device: *const ::std::os::raw::c_char,
    /// < encryption sector size, 0 triggers auto-detection for optimal
    /// encryption sector size
    pub sector_size: u32,
    /// < header label or @e NULL
    pub label: *const ::std::os::raw::c_char,
    /// < header subsystem label or @e NULL
    pub subsystem: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_luks2"][::std::mem::size_of::<crypt_params_luks2>() - 64usize];
    ["Alignment of crypt_params_luks2"][::std::mem::align_of::<crypt_params_luks2>() - 8usize];
    ["Offset of field: crypt_params_luks2::pbkdf"]
        [::std::mem::offset_of!(crypt_params_luks2, pbkdf) - 0usize];
    ["Offset of field: crypt_params_luks2::integrity"]
        [::std::mem::offset_of!(crypt_params_luks2, integrity) - 8usize];
    ["Offset of field: crypt_params_luks2::integrity_params"]
        [::std::mem::offset_of!(crypt_params_luks2, integrity_params) - 16usize];
    ["Offset of field: crypt_params_luks2::data_alignment"]
        [::std::mem::offset_of!(crypt_params_luks2, data_alignment) - 24usize];
    ["Offset of field: crypt_params_luks2::data_device"]
        [::std::mem::offset_of!(crypt_params_luks2, data_device) - 32usize];
    ["Offset of field: crypt_params_luks2::sector_size"]
        [::std::mem::offset_of!(crypt_params_luks2, sector_size) - 40usize];
    ["Offset of field: crypt_params_luks2::label"]
        [::std::mem::offset_of!(crypt_params_luks2, label) - 48usize];
    ["Offset of field: crypt_params_luks2::subsystem"]
        [::std::mem::offset_of!(crypt_params_luks2, subsystem) - 56usize];
};
/// Structure used as parameter for OPAL (HW encrypted) device type.
///
/// @see crypt_format_luks2_opal
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_hw_opal {
    /// < admin key
    pub admin_key: *const ::std::os::raw::c_char,
    /// < admin key size in bytes
    pub admin_key_size: usize,
    /// < user authority key size part in bytes
    pub user_key_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_hw_opal"][::std::mem::size_of::<crypt_params_hw_opal>() - 24usize];
    ["Alignment of crypt_params_hw_opal"][::std::mem::align_of::<crypt_params_hw_opal>() - 8usize];
    ["Offset of field: crypt_params_hw_opal::admin_key"]
        [::std::mem::offset_of!(crypt_params_hw_opal, admin_key) - 0usize];
    ["Offset of field: crypt_params_hw_opal::admin_key_size"]
        [::std::mem::offset_of!(crypt_params_hw_opal, admin_key_size) - 8usize];
    ["Offset of field: crypt_params_hw_opal::user_key_size"]
        [::std::mem::offset_of!(crypt_params_hw_opal, user_key_size) - 16usize];
};
extern "C" {
    /// Create (format) new crypt device (and possible header on-disk) but do
    /// not activate it.
    ///
    /// @pre @e cd contains initialized and not formatted device context (device
    /// type must @b not be set)
    ///
    /// @param cd crypt device handle
    /// @param type type of device (optional params struct must be of this type)
    /// @param cipher (e.g. "aes")
    /// @param cipher_mode including IV specification (e.g. "xts-plain")
    /// @param uuid requested UUID or @e NULL if it should be generated
    /// @param volume_key pre-generated volume key or @e NULL if it should be
    /// generated (only for LUKS) @param volume_key_size size of volume key
    /// in bytes. @param params crypt type specific parameters (see @link
    /// crypt-type @endlink)
    ///
    /// @returns @e 0 on success or negative errno value otherwise.
    ///
    /// @note Note that crypt_format does not create LUKS keyslot (any version).
    /// To create keyslot 	 call any crypt_keyslot_add_* function.
    /// @note For VERITY @link crypt-type @endlink, only uuid parameter is used,
    /// other parameters 	are ignored and verity specific attributes are set
    /// through mandatory params option.
    pub fn crypt_format(
        cd: *mut crypt_device,
        type_: *const ::std::os::raw::c_char,
        cipher: *const ::std::os::raw::c_char,
        cipher_mode: *const ::std::os::raw::c_char,
        uuid: *const ::std::os::raw::c_char,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
        params: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Create (format) new LUKS2 crypt device over HW OPAL device but do not
    /// activate it.
    ///
    /// @pre @e cd contains initialized and not formatted device context (device
    /// type must @b not be set)
    ///
    /// @param cd crypt device handle
    /// @param cipher for SW encryption (e.g. "aes") or NULL for HW encryption
    /// only @param cipher_mode including IV specification (e.g.
    /// "xts-plain") or NULL for HW encryption only @param uuid requested
    /// UUID or @e NULL if it should be generated @param volume_keys
    /// pre-generated volume keys or @e NULL if it should be generated (only for
    /// LUKS2 SW encryption) @param volume_keys_size size of volume keys in
    /// bytes (only for SW encryption). @param params LUKS2 crypt type
    /// specific parameters (see @link crypt-type @endlink)
    /// @param opal_params OPAL specific parameters
    ///
    /// @returns @e 0 on success or negative errno value otherwise.
    ///
    /// @note Note that crypt_format_luks2_opal does not create LUKS keyslot.
    ///       To create keyslot call any crypt_keyslot_add_* function.
    pub fn crypt_format_luks2_opal(
        cd: *mut crypt_device,
        cipher: *const ::std::os::raw::c_char,
        cipher_mode: *const ::std::os::raw::c_char,
        uuid: *const ::std::os::raw::c_char,
        volume_keys: *const ::std::os::raw::c_char,
        volume_keys_size: usize,
        params: *mut crypt_params_luks2,
        opal_params: *mut crypt_params_hw_opal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set format compatibility flags.
    ///
    /// @param cd crypt device handle
    /// @param flags CRYPT_COMPATIBILITY_* flags
    pub fn crypt_set_compatibility(cd: *mut crypt_device, flags: u32);
}
extern "C" {
    /// Get compatibility flags.
    ///
    /// @param cd crypt device handle
    ///
    /// @returns compatibility flags
    pub fn crypt_get_compatibility(cd: *mut crypt_device) -> u32;
}
extern "C" {
    /// Convert to new type for already existing device.
    ///
    /// @param cd crypt device handle
    /// @param type type of device (optional params struct must be of this type)
    /// @param params crypt type specific parameters (see @link crypt-type
    /// @endlink)
    ///
    /// @returns 0 on success or negative errno value otherwise.
    ///
    /// @note Currently, only LUKS1->LUKS2 and LUKS2->LUKS1 conversions are
    /// supported. 	 Not all LUKS2 devices may be converted back to LUKS1.
    /// To make such a conversion 	 possible all active LUKS2 keyslots must
    /// be in LUKS1 compatible mode (i.e. pbkdf 	 type must be PBKDF2) and
    /// device cannot be formatted with any authenticated 	 encryption mode.
    ///
    /// @note Device must be offline for conversion. UUID change is not possible
    /// for active 	 devices.
    pub fn crypt_convert(
        cd: *mut crypt_device,
        type_: *const ::std::os::raw::c_char,
        params: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set new UUID for already existing device.
    ///
    /// @param cd crypt device handle
    /// @param uuid requested UUID or @e NULL if it should be generated
    ///
    /// @returns 0 on success or negative errno value otherwise.
    ///
    /// @note Currently, only LUKS device type are supported
    pub fn crypt_set_uuid(
        cd: *mut crypt_device,
        uuid: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set new labels (label and subsystem) for already existing device.
    ///
    /// @param cd crypt device handle
    /// @param label requested label or @e NULL
    /// @param subsystem requested subsystem label or @e NULL
    ///
    /// @returns 0 on success or negative errno value otherwise.
    ///
    /// @note Currently, only LUKS2 device type is supported
    pub fn crypt_set_label(
        cd: *mut crypt_device,
        label: *const ::std::os::raw::c_char,
        subsystem: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the label of an existing device.
    ///
    /// @param cd crypt device handle
    ///
    /// @return label, or @e NULL otherwise
    pub fn crypt_get_label(cd: *mut crypt_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the subsystem of an existing device.
    ///
    /// @param cd crypt device handle
    ///
    /// @return subsystem, or @e NULL otherwise
    pub fn crypt_get_subsystem(cd: *mut crypt_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Enable or disable loading of volume keys via kernel keyring. When set to
    /// 'enabled' library loads key in kernel keyring first and pass the key
    /// description to dm-crypt instead of binary key copy. If set to 'disabled'
    /// library fallbacks to old method of loading volume key directly in
    /// dm-crypt target.
    ///
    /// @param cd crypt device handle, can be @e NULL
    /// @param enable 0 to disable loading of volume keys via kernel keyring
    /// 	  (classical method) otherwise enable it (default)
    ///
    /// @returns @e 0 on success or negative errno value otherwise.
    ///
    /// @note Currently loading of volume keys via kernel keyring is supported
    /// 	 (and enabled by default) only for LUKS2 devices.
    /// @note The switch is global on the library level.
    pub fn crypt_volume_key_keyring(
        cd: *mut crypt_device,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Load crypt device parameters from on-disk header.
    ///
    /// @param cd crypt device handle
    /// @param requested_type @link crypt-type @endlink or @e NULL for all known
    /// @param params crypt type specific parameters (see @link crypt-type
    /// @endlink)
    ///
    /// @returns 0 on success or negative errno value otherwise.
    ///
    /// @post In case LUKS header is read successfully but payload device is too
    /// small error is returned and device type in context is set to @e NULL
    ///
    /// @note Note that load works only for device types with on-disk metadata.
    /// @note Function does not print visible error message if metadata is not
    /// present.
    pub fn crypt_load(
        cd: *mut crypt_device,
        requested_type: *const ::std::os::raw::c_char,
        params: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Try to repair crypt device LUKS on-disk header if invalid.
    ///
    /// @param cd crypt device handle
    /// @param requested_type @link crypt-type @endlink or @e NULL for all known
    /// @param params crypt type specific parameters (see @link crypt-type
    /// @endlink)
    ///
    /// @returns 0 on success or negative errno value otherwise.
    ///
    /// @note For LUKS2 device crypt_repair bypass blkid checks and
    /// 	 perform auto-recovery even though there're third party device
    /// 	 signatures found by blkid probes. Currently the crypt_repair on LUKS2
    /// 	 works only if exactly one header checksum does not match or exactly
    /// 	 one header is missing.
    pub fn crypt_repair(
        cd: *mut crypt_device,
        requested_type: *const ::std::os::raw::c_char,
        params: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Resize crypt device.
    ///
    /// @param cd - crypt device handle
    /// @param name - name of device to resize
    /// @param new_size - new device size in sectors or @e 0 to use all of the
    /// underlying device size
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note Most notably it returns -EPERM when device was activated with
    /// volume key 	 in kernel keyring and current device handle (context)
    /// doesn't have verified key 	 loaded in kernel. To load volume key for
    /// already active device use any of
    /// 	 @link crypt_activate_by_passphrase @endlink, @link
    /// crypt_activate_by_keyfile @endlink,
    /// 	 @link crypt_activate_by_keyfile_offset @endlink, @link
    /// crypt_activate_by_volume_key @endlink,
    /// 	 @link crypt_activate_by_keyring @endlink or @link
    /// crypt_activate_by_token @endlink with flag
    /// 	 @e CRYPT_ACTIVATE_KEYRING_KEY raised and @e name parameter set to @e
    /// NULL.
    pub fn crypt_resize(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        new_size: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Suspend crypt device.
    ///
    /// @param cd crypt device handle, can be @e NULL
    /// @param name name of device to suspend
    ///
    /// @return 0 on success or negative errno value otherwise.
    ///
    /// @note Only LUKS device type is supported
    pub fn crypt_suspend(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Resume crypt device using passphrase.
    ///
    ///
    /// @param cd crypt device handle
    /// @param name name of device to resume
    /// @param keyslot requested keyslot or CRYPT_ANY_SLOT
    /// @param passphrase passphrase used to unlock volume key
    /// @param passphrase_size size of @e passphrase (binary data)
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    ///
    /// @note Only LUKS device type is supported
    pub fn crypt_resume_by_passphrase(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Resume crypt device using key file.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to resume
    /// @param keyslot requested keyslot or CRYPT_ANY_SLOT
    /// @param keyfile key file used to unlock volume key
    /// @param keyfile_size number of bytes to read from keyfile, 0 is unlimited
    /// @param keyfile_offset number of bytes to skip at start of keyfile
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    pub fn crypt_resume_by_keyfile_device_offset(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        keyfile_offset: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Backward compatible crypt_resume_by_keyfile_device_offset() (with size_t
    /// offset).
    pub fn crypt_resume_by_keyfile_offset(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        keyfile_offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Backward compatible crypt_resume_by_keyfile_device_offset() (without
    /// offset).
    pub fn crypt_resume_by_keyfile(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Resume crypt device using provided volume key.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to resume
    /// @param volume_key provided volume key
    /// @param volume_key_size size of volume_key
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_resume_by_volume_key(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Resume crypt device using LUKS2 token.
    ///
    /// @param cd LUKS2 crypt device handle
    /// @param name name of device to resume
    /// @param type restrict type of token, if @e NULL all types are allowed
    /// @param pin passphrase (or PIN) to unlock token (may be binary data)
    /// @param pin_size size of @e pin
    /// @param usrptr provided identification in callback
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    ///
    /// @note EPERM errno means token provided passphrase successfully, but
    ///       passphrase did not unlock any keyslot associated with the token.
    ///
    /// @note ENOENT errno means no token (or subsequently assigned keyslot) was
    ///       eligible to resume LUKS2 device.
    ///
    /// @note ENOANO errno means that token is PIN protected and was either
    /// missing       (NULL) or wrong.
    ///
    /// @note Negative EAGAIN errno means token handler requires additional
    /// hardware       not present in the system to unlock keyslot.
    ///
    /// @note with @param token set to CRYPT_ANY_TOKEN libcryptsetup runs best
    /// effort loop       to resume device using any available token. It may
    /// happen that various token handlers       return different error
    /// codes. At the end loop returns error codes in the following
    ///       order (from the most significant to the least) any negative errno
    /// except those       listed below, non negative token id (success),
    /// -ENOANO, -EAGAIN, -EPERM, -ENOENT.
    pub fn crypt_resume_by_token_pin(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        token: ::std::os::raw::c_int,
        pin: *const ::std::os::raw::c_char,
        pin_size: usize,
        usrptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Resume crypt device using keyslot context.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to resume
    /// @param keyslot requested keyslot to check or @e CRYPT_ANY_SLOT, keyslot
    /// is        ignored for unlock methods not based on passphrase
    /// @param kc keyslot context providing volume key or passphrase.
    ///
    /// @return unlocked key slot number for passphrase-based unlock, zero for
    /// other         unlock methods (e.g. volume key context) or negative
    /// errno on error.
    pub fn crypt_resume_by_keyslot_context(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        kc: *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add key slot using provided passphrase.
    ///
    /// @pre @e cd contains initialized and formatted LUKS device context
    ///
    /// @param cd crypt device handle
    /// @param keyslot requested keyslot or @e CRYPT_ANY_SLOT
    /// @param passphrase passphrase used to unlock volume key
    /// @param passphrase_size size of passphrase (binary data)
    /// @param new_passphrase passphrase for new keyslot
    /// @param new_passphrase_size size of @e new_passphrase (binary data)
    ///
    /// @return allocated key slot number or negative errno otherwise.
    pub fn crypt_keyslot_add_by_passphrase(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
        new_passphrase: *const ::std::os::raw::c_char,
        new_passphrase_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Change defined key slot using provided passphrase.
    ///
    /// @pre @e cd contains initialized and formatted LUKS device context
    ///
    /// @param cd crypt device handle
    /// @param keyslot_old old keyslot or @e CRYPT_ANY_SLOT
    /// @param keyslot_new new keyslot (can be the same as old)
    /// @param passphrase passphrase used to unlock volume key
    /// @param passphrase_size size of passphrase (binary data)
    /// @param new_passphrase passphrase for new keyslot
    /// @param new_passphrase_size size of @e new_passphrase (binary data)
    ///
    /// @return allocated key slot number or negative errno otherwise.
    pub fn crypt_keyslot_change_by_passphrase(
        cd: *mut crypt_device,
        keyslot_old: ::std::os::raw::c_int,
        keyslot_new: ::std::os::raw::c_int,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
        new_passphrase: *const ::std::os::raw::c_char,
        new_passphrase_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add key slot using provided key file path.
    ///
    /// @pre @e cd contains initialized and formatted LUKS device context
    ///
    /// @param cd crypt device handle
    /// @param keyslot requested keyslot or @e CRYPT_ANY_SLOT
    /// @param keyfile key file used to unlock volume key
    /// @param keyfile_size number of bytes to read from keyfile, @e 0 is
    /// unlimited @param keyfile_offset number of bytes to skip at start of
    /// keyfile @param new_keyfile keyfile for new keyslot
    /// @param new_keyfile_size number of bytes to read from @e new_keyfile, @e
    /// 0 is unlimited @param new_keyfile_offset number of bytes to skip at
    /// start of new_keyfile
    ///
    /// @return allocated key slot number or negative errno otherwise.
    pub fn crypt_keyslot_add_by_keyfile_device_offset(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        keyfile_offset: u64,
        new_keyfile: *const ::std::os::raw::c_char,
        new_keyfile_size: usize,
        new_keyfile_offset: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Backward compatible crypt_keyslot_add_by_keyfile_device_offset() (with
    /// size_t offset).
    pub fn crypt_keyslot_add_by_keyfile_offset(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        keyfile_offset: usize,
        new_keyfile: *const ::std::os::raw::c_char,
        new_keyfile_size: usize,
        new_keyfile_offset: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Backward compatible crypt_keyslot_add_by_keyfile_device_offset()
    /// (without offset).
    pub fn crypt_keyslot_add_by_keyfile(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        new_keyfile: *const ::std::os::raw::c_char,
        new_keyfile_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add key slot using provided volume key.
    ///
    /// @pre @e cd contains initialized and formatted LUKS device context
    ///
    /// @param cd crypt device handle
    /// @param keyslot requested keyslot or CRYPT_ANY_SLOT
    /// @param volume_key provided volume key or @e NULL if used after
    /// crypt_format @param volume_key_size size of volume_key
    /// @param passphrase passphrase for new keyslot
    /// @param passphrase_size size of passphrase
    ///
    /// @return allocated key slot number or negative errno otherwise.
    pub fn crypt_keyslot_add_by_volume_key(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add key slot using provided key.
    ///
    /// @pre @e cd contains initialized and formatted LUKS2 device context
    ///
    /// @param cd crypt device handle
    /// @param keyslot requested keyslot or CRYPT_ANY_SLOT
    /// @param volume_key provided volume key or @e NULL (see note below)
    /// @param volume_key_size size of volume_key
    /// @param passphrase passphrase for new keyslot
    /// @param passphrase_size size of passphrase
    /// @param flags key flags to set
    ///
    /// @return allocated key slot number or negative errno otherwise.
    ///
    /// @note in case volume_key is @e NULL following first matching rule will
    /// apply: @li if cd is device handle used in crypt_format() by current
    /// process, the volume     key generated (or passed) in crypt_format()
    /// will be stored in keyslot. @li if CRYPT_VOLUME_KEY_NO_SEGMENT flag
    /// is raised the new volume_key will be     generated and stored in
    /// keyslot. The keyslot will become unbound (unusable to     dm-crypt
    /// device activation). @li fails with -EINVAL otherwise
    ///
    /// @warning CRYPT_VOLUME_KEY_SET flag force updates volume key. It is @b
    /// not @b reencryption! 	    By doing so you will most probably destroy
    /// your ciphertext data device. It's supposed 	    to be used only in
    /// wrapped keys scheme for key refresh process where real (inner) volume
    /// 	    key stays untouched. It may be involved on active @e keyslot which
    /// makes the (previously 	    unbound) keyslot new regular keyslot.
    pub fn crypt_keyslot_add_by_key(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Release crypt keyslot context and used memory.
    ///
    /// @param kc crypt keyslot context
    pub fn crypt_keyslot_context_free(kc: *mut crypt_keyslot_context);
}
extern "C" {
    /// Initialize keyslot context via passphrase.
    ///
    /// @param cd crypt device handle initialized to LUKS device context
    /// @param passphrase passphrase for a keyslot
    /// @param passphrase_size size of passphrase
    /// @param kc returns crypt keyslot context handle type
    /// CRYPT_KC_TYPE_PASSPHRASE
    ///
    /// @return zero on success or negative errno otherwise.
    pub fn crypt_keyslot_context_init_by_passphrase(
        cd: *mut crypt_device,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
        kc: *mut *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize keyslot context via key file path.
    ///
    /// @param cd crypt device handle initialized to LUKS device context
    ///
    /// @param keyfile key file with passphrase for a keyslot
    /// @param keyfile_size number of bytes to read from keyfile, @e 0 is
    /// unlimited @param keyfile_offset number of bytes to skip at start of
    /// keyfile @param kc returns crypt keyslot context handle type
    /// CRYPT_KC_TYPE_KEYFILE
    ///
    /// @return zero on success or negative errno otherwise.
    pub fn crypt_keyslot_context_init_by_keyfile(
        cd: *mut crypt_device,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        keyfile_offset: u64,
        kc: *mut *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize keyslot context via LUKS2 token.
    ///
    /// @param cd crypt device handle initialized to LUKS2 device context
    ///
    /// @param token token providing passphrase for a keyslot or CRYPT_ANY_TOKEN
    /// @param type restrict type of token, if @e NULL all types are allowed
    /// @param pin passphrase (or PIN) to unlock token (may be binary data)
    /// @param pin_size size of @e pin
    /// @param usrptr provided identification in callback
    /// @param kc returns crypt keyslot context handle type CRYPT_KC_TYPE_TOKEN
    ///
    /// @return zero on success or negative errno otherwise.
    pub fn crypt_keyslot_context_init_by_token(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        type_: *const ::std::os::raw::c_char,
        pin: *const ::std::os::raw::c_char,
        pin_size: usize,
        usrptr: *mut ::std::os::raw::c_void,
        kc: *mut *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize keyslot context via key.
    ///
    /// @param cd crypt device handle initialized to LUKS device context
    ///
    /// @param volume_key provided volume key or @e NULL if used after
    /// crypt_format        or with CRYPT_VOLUME_KEY_NO_SEGMENT flag
    /// @param volume_key_size size of volume_key
    /// @param kc returns crypt keyslot context handle type CRYPT_KC_TYPE_KEY
    ///
    /// @return zero on success or negative errno otherwise.
    pub fn crypt_keyslot_context_init_by_volume_key(
        cd: *mut crypt_device,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
        kc: *mut *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize keyslot context via signed key.
    ///
    /// @param cd crypt device handle initialized to device context
    ///
    /// @param volume_key provided volume key
    /// @param volume_key_size size of volume_key
    /// @param signature buffer with signature for the key
    /// @param signature_size bsize of signature buffer
    /// @param kc returns crypt keyslot context handle type
    /// CRYPT_KC_TYPE_SIGNED_KEY
    ///
    /// @return zero on success or negative errno otherwise.
    ///
    /// @note currently supported only with VERITY devices.
    pub fn crypt_keyslot_context_init_by_signed_key(
        cd: *mut crypt_device,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
        signature: *const ::std::os::raw::c_char,
        signature_size: usize,
        kc: *mut *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize keyslot context via passphrase stored in a keyring.
    ///
    /// @param cd crypt device handle initialized to LUKS device context
    ///
    /// @param key_description kernel keyring key description library should
    /// look        for passphrase in
    /// @param kc returns crypt keyslot context handle type
    /// CRYPT_KC_TYPE_KEYRING
    ///
    /// @return zero on success or negative errno otherwise.
    pub fn crypt_keyslot_context_init_by_keyring(
        cd: *mut crypt_device,
        key_description: *const ::std::os::raw::c_char,
        kc: *mut *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize keyslot context via volume key stored in a keyring.
    ///
    /// @param cd crypt device handle initialized to LUKS device context
    ///
    /// @param key_description kernel keyring key description library should
    /// look        for passphrase in. The key can be passed either as
    /// number in ASCII,        or a text representation in the form
    /// "%<key_type>:<key_name>" @param kc returns crypt keyslot context
    /// handle type CRYPT_KC_TYPE_KEYRING
    ///
    /// @return zero on success or negative errno otherwise.
    pub fn crypt_keyslot_context_init_by_vk_in_keyring(
        cd: *mut crypt_device,
        key_description: *const ::std::os::raw::c_char,
        kc: *mut *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get error code per keyslot context from last failed call.
    ///
    /// @note If @link crypt_keyslot_add_by_keyslot_context @endlink passed with
    /// 	 no negative return code. The return value of this function is
    /// undefined.
    ///
    /// @param kc keyslot context involved in failed @link
    /// crypt_keyslot_add_by_keyslot_context @endlink
    ///
    /// @return Negative errno if keyslot context caused a failure, zero
    /// otherwise.
    pub fn crypt_keyslot_context_get_error(kc: *mut crypt_keyslot_context)
        -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set new pin to token based keyslot context.
    ///
    /// @note Use when @link crypt_keyslot_add_by_keyslot_context @endlink
    /// failed 	 and token keyslot context returned -ENOANO error code via
    /// 	 @link crypt_keyslot_context_get_error @endlink.
    ///
    /// @param cd crypt device handle initialized to LUKS2 device context
    /// @param pin passphrase (or PIN) to unlock token (may be binary data)
    /// @param pin_size size of @e pin
    /// @param kc LUKS2 keyslot context (only @link CRYPT_KC_TYPE_TOKEN @endlink
    /// is allowed)
    ///
    /// @return zero on success or negative errno otherwise
    pub fn crypt_keyslot_context_set_pin(
        cd: *mut crypt_device,
        pin: *const ::std::os::raw::c_char,
        pin_size: usize,
        kc: *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get type identifier for crypt keyslot context.
    ///
    /// @param kc keyslot context
    ///
    /// @return crypt keyslot context type id (see @link
    /// crypt-keyslot-context-types @endlink) or negative errno otherwise.
    pub fn crypt_keyslot_context_get_type(
        kc: *const crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add key slot by volume key provided by keyslot context (kc). New
    /// keyslot will be protected by passphrase provided by new keyslot context
    /// (new_kc). See @link crypt-keyslot-context @endlink for context
    /// initialization routines.
    ///
    /// @pre @e cd contains initialized and formatted LUKS device context.
    ///
    /// @param cd crypt device handle
    /// @param keyslot_existing existing keyslot or CRYPT_ANY_SLOT to get volume
    /// key from. @param kc keyslot context providing volume key.
    /// @param keyslot_new new keyslot or CRYPT_ANY_SLOT (first free number is
    /// used). @param new_kc keyslot context providing passphrase for new
    /// keyslot. @param flags key flags to set
    ///
    /// @return allocated key slot number or negative errno otherwise.
    ///
    /// @note new_kc can not be @e CRYPT_KC_TYPE_KEY type keyslot context.
    ///
    /// @note For kc parameter with type @e CRYPT_KC_TYPE_KEY the
    /// keyslot_existing       parameter is ignored.
    ///
    /// @note in case there is no active LUKS keyslot to get existing volume key
    /// from, one of following must apply: 	 @li @e cd must be device handle
    /// used in crypt_format() by current process (it holds reference to
    /// generated volume key) 	 @li kc must be of @e CRYPT_KC_TYPE_KEY type
    /// with valid volume key.
    ///
    /// @note With CRYPT_VOLUME_KEY_NO_SEGMENT flag raised and kc of type @e
    /// CRYPT_KC_TYPE_KEY with @e volume_key set to @e NULL     the new
    /// volume_key will be generated and stored in new keyslot. The keyslot will
    /// become unbound (unusable to     dm-crypt device activation).
    ///
    /// @warning CRYPT_VOLUME_KEY_SET flag force updates volume key. It is @b
    /// not @b reencryption! 	    By doing so you will most probably destroy
    /// your ciphertext data device. It's supposed 	    to be used only in
    /// wrapped keys scheme for key refresh process where real (inner) volume
    /// 	    key stays untouched. It may be involved on active @e keyslot which
    /// makes the (previously 	    unbound) keyslot new regular keyslot.
    pub fn crypt_keyslot_add_by_keyslot_context(
        cd: *mut crypt_device,
        keyslot_existing: ::std::os::raw::c_int,
        kc: *mut crypt_keyslot_context,
        keyslot_new: ::std::os::raw::c_int,
        new_kc: *mut crypt_keyslot_context,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Destroy (and disable) key slot.
    ///
    /// @pre @e cd contains initialized and formatted LUKS device context
    ///
    /// @param cd crypt device handle
    /// @param keyslot requested key slot to destroy
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note Note that there is no passphrase verification used.
    pub fn crypt_keyslot_destroy(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
/// Active device runtime attributes
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_active_device {
    /// < offset in sectors
    pub offset: u64,
    /// < IV initialization sector
    pub iv_offset: u64,
    /// < active device size
    pub size: u64,
    /// < activation flags
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_active_device"][::std::mem::size_of::<crypt_active_device>() - 32usize];
    ["Alignment of crypt_active_device"][::std::mem::align_of::<crypt_active_device>() - 8usize];
    ["Offset of field: crypt_active_device::offset"]
        [::std::mem::offset_of!(crypt_active_device, offset) - 0usize];
    ["Offset of field: crypt_active_device::iv_offset"]
        [::std::mem::offset_of!(crypt_active_device, iv_offset) - 8usize];
    ["Offset of field: crypt_active_device::size"]
        [::std::mem::offset_of!(crypt_active_device, size) - 16usize];
    ["Offset of field: crypt_active_device::flags"]
        [::std::mem::offset_of!(crypt_active_device, flags) - 24usize];
};
extern "C" {
    /// Receive runtime attributes of active crypt device.
    ///
    /// @param cd crypt device handle (can be @e NULL)
    /// @param name name of active device
    /// @param cad preallocated active device attributes to fill
    ///
    /// @return @e 0 on success or negative errno value otherwise
    pub fn crypt_get_active_device(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        cad: *mut crypt_active_device,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get detected number of integrity failures.
    ///
    /// @param cd crypt device handle (can be @e NULL)
    /// @param name name of active device
    ///
    /// @return number of integrity failures or @e 0 otherwise
    pub fn crypt_get_active_integrity_failures(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
    ) -> u64;
}
/// < activation flags, @see aflags
pub const crypt_flags_type_CRYPT_FLAGS_ACTIVATION: crypt_flags_type = 0;
/// < requirements flags
pub const crypt_flags_type_CRYPT_FLAGS_REQUIREMENTS: crypt_flags_type = 1;
/// Persistent flags type
pub type crypt_flags_type = ::std::os::raw::c_uint;
extern "C" {
    /// Set persistent flags.
    ///
    /// @param cd crypt device handle (can be @e NULL)
    /// @param type type to set (CRYPT_FLAGS_ACTIVATION or
    /// CRYPT_FLAGS_REQUIREMENTS) @param flags flags to set
    ///
    /// @return @e 0 on success or negative errno value otherwise
    ///
    /// @note Valid only for LUKS2.
    ///
    /// @note Not all activation flags can be stored. Only ALLOW_DISCARD,
    /// 	 SAME_CPU_CRYPT, SUBMIT_FROM_CRYPT_CPU and NO_JOURNAL can be
    /// 	 stored persistently.
    ///
    /// @note Only requirements flags recognised by current library may be set.
    /// 	 CRYPT_REQUIREMENT_UNKNOWN is illegal (output only) in set operation.
    pub fn crypt_persistent_flags_set(
        cd: *mut crypt_device,
        type_: crypt_flags_type,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get persistent flags stored in header.
    ///
    /// @param cd crypt device handle (can be @e NULL)
    /// @param type flags type to retrieve (CRYPT_FLAGS_ACTIVATION or
    /// CRYPT_FLAGS_REQUIREMENTS) @param flags reference to output variable
    ///
    /// @return @e 0 on success or negative errno value otherwise
    pub fn crypt_persistent_flags_get(
        cd: *mut crypt_device,
        type_: crypt_flags_type,
        flags: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Activate device or check using keyslot context. In some cases (device
    /// under reencryption), more than one keyslot context is required (e.g.
    /// one for the old volume key and one for the new volume key). The
    /// order of the keyslot contexts does not matter. When less keyslot
    /// contexts are supplied than required to unlock the device an -ESRCH
    /// error code is returned and you should call the function again with
    /// an additional keyslot context specified.
    ///
    /// NOTE: the API at the moment fully works for single keyslot context only,
    /// the additional keyslot context currently works only with
    /// @e CRYPT_KC_TYPE_VK_KEYRING or @e CRYPT_KC_TYPE_KEY contexts.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to create, if @e NULL only check passphrase
    /// @param keyslot requested keyslot to check or @e CRYPT_ANY_SLOT, keyslot
    /// is        ignored for unlock methods not based on passphrase
    /// @param kc keyslot context providing volume key or passphrase.
    /// @param additional_keyslot requested additional keyslot to check or @e
    /// CRYPT_ANY_SLOT @param additional_kc keyslot context providing
    /// additional volume key or        passphrase (e.g. old volume key for
    /// device under reencryption). @param flags activation flags
    ///
    /// @return unlocked key slot number for passphrase-based unlock, zero for
    /// other         unlock methods (e.g. volume key context) or negative
    /// errno on error.
    pub fn crypt_activate_by_keyslot_context(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        kc: *mut crypt_keyslot_context,
        additional_keyslot: ::std::os::raw::c_int,
        additional_kc: *mut crypt_keyslot_context,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Activate device or check passphrase.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to create, if @e NULL only check passphrase
    /// @param keyslot requested keyslot to check or @e CRYPT_ANY_SLOT
    /// @param passphrase passphrase used to unlock volume key
    /// @param passphrase_size size of @e passphrase
    /// @param flags activation flags
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    pub fn crypt_activate_by_passphrase(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Activate device or check using key file.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to create, if @e NULL only check keyfile
    /// @param keyslot requested keyslot to check or CRYPT_ANY_SLOT
    /// @param keyfile key file used to unlock volume key
    /// @param keyfile_size number of bytes to read from keyfile, 0 is unlimited
    /// @param keyfile_offset number of bytes to skip at start of keyfile
    /// @param flags activation flags
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    pub fn crypt_activate_by_keyfile_device_offset(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        keyfile_offset: u64,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Backward compatible crypt_activate_by_keyfile_device_offset() (with
    /// size_t offset).
    pub fn crypt_activate_by_keyfile_offset(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        keyfile_offset: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Backward compatible crypt_activate_by_keyfile_device_offset() (without
    /// offset).
    pub fn crypt_activate_by_keyfile(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        keyfile: *const ::std::os::raw::c_char,
        keyfile_size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Activate device using provided volume key.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to create, if @e NULL only check volume key
    /// @param volume_key provided volume key (or @e NULL to use internal)
    /// @param volume_key_size size of volume_key
    /// @param flags activation flags
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note If @e NULL is used for volume_key, device has to be initialized
    /// 	 by previous operation (like @ref crypt_format
    /// 	 or @ref crypt_init_by_name)
    /// @note For VERITY the volume key means root hash required for activation.
    /// 	 Because kernel dm-verity is always read only, you have to provide
    /// 	 CRYPT_ACTIVATE_READONLY flag always.
    /// @note For TCRYPT the volume key should be always NULL
    /// 	 the key from decrypted header is used instead.
    /// @note For BITLK the name cannot be @e NULL checking volume key is not
    /// 	 supported for BITLK, the device will be activated even if the
    /// 	 provided key is not correct.
    pub fn crypt_activate_by_volume_key(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Activate VERITY device using provided key and optional signature).
    ///
    /// @param cd crypt device handle
    /// @param name name of device to create
    /// @param volume_key provided volume key
    /// @param volume_key_size size of volume_key
    /// @param signature buffer with signature for the key
    /// @param signature_size bsize of signature buffer
    /// @param flags activation flags
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note For VERITY the volume key means root hash required for activation.
    /// 	Because kernel dm-verity is always read only, you have to provide
    /// 	CRYPT_ACTIVATE_READONLY flag always.
    pub fn crypt_activate_by_signed_key(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
        signature: *const ::std::os::raw::c_char,
        signature_size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Activate device using passphrase stored in kernel keyring.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to create, if @e NULL only check passphrase
    /// in keyring @param key_description kernel keyring key description
    /// library should look        for passphrase in
    /// @param keyslot requested keyslot to check or CRYPT_ANY_SLOT
    /// @param flags activation flags
    ///
    /// @return @e unlocked keyslot number on success or negative errno value
    /// otherwise.
    ///
    /// @note Keyslot passphrase must be stored in 'user' key type
    /// 	 and the key has to be reachable for process context
    /// 	 on behalf of which this function is called.
    pub fn crypt_activate_by_keyring(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        key_description: *const ::std::os::raw::c_char,
        keyslot: ::std::os::raw::c_int,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Deactivate crypt device. This function tries to remove active
    /// device-mapper mapping from kernel. Also, sensitive data like the
    /// volume key are removed from memory
    ///
    /// @param cd crypt device handle, can be @e NULL
    /// @param name name of device to deactivate
    /// @param flags deactivation flags
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_deactivate_by_name(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Deactivate crypt device. See @ref crypt_deactivate_by_name with empty @e
    /// flags.
    pub fn crypt_deactivate(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get volume key from crypt device.
    ///
    /// @param cd crypt device handle
    /// @param keyslot use this keyslot or @e CRYPT_ANY_SLOT
    /// @param volume_key buffer for volume key
    /// @param volume_key_size on input, size of buffer @e volume_key,
    ///        on output size of @e volume_key
    /// @param passphrase passphrase used to unlock volume key
    /// @param passphrase_size size of @e passphrase
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    ///
    /// @note For TCRYPT cipher chain is the volume key concatenated
    /// 	 for all ciphers in chain.
    /// @note For VERITY the volume key means root hash used for activation.
    /// @note For LUKS devices, if passphrase is @e NULL and volume key is
    /// cached in 	 device context it returns the volume key generated in
    /// preceding 	 @link crypt_format @endlink call.
    pub fn crypt_volume_key_get(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        volume_key: *mut ::std::os::raw::c_char,
        volume_key_size: *mut usize,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get volume key from crypt device by keyslot context.
    ///
    /// @param cd crypt device handle
    /// @param keyslot use this keyslot or @e CRYPT_ANY_SLOT
    /// @param volume_key buffer for volume key
    /// @param volume_key_size on input, size of buffer @e volume_key,
    ///        on output size of @e volume_key
    /// @param kc keyslot context used to unlock volume key
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    ///
    /// @note See @link crypt-keyslot-context-types @endlink for info on keyslot
    /// 	 context initialization.
    /// @note For TCRYPT cipher chain is the volume key concatenated
    /// 	 for all ciphers in chain (kc may be NULL).
    /// @note For VERITY the volume key means root hash used for activation
    /// 	 (kc may be NULL).
    /// @note For LUKS devices, if kc is @e NULL and volume key is cached in
    /// 	 device context it returns the volume key generated in preceding
    /// 	 @link crypt_format @endlink call.
    /// @note @link CRYPT_KC_TYPE_TOKEN @endlink keyslot context is usable only
    /// with LUKS2 devices. @note @link CRYPT_KC_TYPE_KEY @endlink keyslot
    /// context can not be used. @note To get LUKS2 unbound key, keyslot
    /// parameter must not be @e CRYPT_ANY_SLOT. @note EPERM errno means
    /// provided keyslot context could not unlock any (or selected)
    /// 	 keyslot.
    /// @note ENOENT errno means no LUKS keyslot is available to retrieve volume
    /// key from 	 and there's no cached volume key in device handle.
    pub fn crypt_volume_key_get_by_keyslot_context(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        volume_key: *mut ::std::os::raw::c_char,
        volume_key_size: *mut usize,
        kc: *mut crypt_keyslot_context,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Verify that provided volume key is valid for crypt device.
    ///
    /// @param cd crypt device handle
    /// @param volume_key provided volume key
    /// @param volume_key_size size of @e volume_key
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note Negative EPERM return value means that passed volume_key
    /// 	 did not pass digest verification routine (not a valid volume
    /// 	 key).
    pub fn crypt_volume_key_verify(
        cd: *mut crypt_device,
        volume_key: *const ::std::os::raw::c_char,
        volume_key_size: usize,
    ) -> ::std::os::raw::c_int;
}
/// < device mapping is invalid in this context
pub const crypt_status_info_CRYPT_INVALID: crypt_status_info = 0;
/// < no such mapped device
pub const crypt_status_info_CRYPT_INACTIVE: crypt_status_info = 1;
/// < device is active
pub const crypt_status_info_CRYPT_ACTIVE: crypt_status_info = 2;
/// < device is active and has open count > 0
pub const crypt_status_info_CRYPT_BUSY: crypt_status_info = 3;
/// Device status
pub type crypt_status_info = ::std::os::raw::c_uint;
extern "C" {
    /// Get status info about device name.
    ///
    /// @param cd crypt device handle, can be @e NULL
    /// @param name crypt device name
    ///
    /// @return value defined by crypt_status_info.
    pub fn crypt_status(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
    ) -> crypt_status_info;
}
extern "C" {
    /// Dump text-formatted information about crypt or verity device to log
    /// output.
    ///
    /// @param cd crypt device handle
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_dump(cd: *mut crypt_device) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dump JSON-formatted information about LUKS2 device
    ///
    /// @param cd crypt device handle (only LUKS2 format supported)
    /// @param json buffer with JSON, if NULL use log callback for output
    /// @param flags dump flags (reserved)
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_dump_json(
        cd: *mut crypt_device,
        json: *mut *const ::std::os::raw::c_char,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get cipher used in device.
    ///
    /// @param cd crypt device handle
    ///
    /// @return used cipher, e.g. "aes" or @e NULL otherwise
    pub fn crypt_get_cipher(cd: *mut crypt_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get cipher mode used in device.
    ///
    /// @param cd crypt device handle
    ///
    /// @return used cipher mode e.g. "xts-plain" or @e otherwise
    pub fn crypt_get_cipher_mode(cd: *mut crypt_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get device UUID.
    ///
    /// @param cd crypt device handle
    ///
    /// @return device UUID or @e NULL if not set
    pub fn crypt_get_uuid(cd: *mut crypt_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get path to underlying device.
    ///
    /// @param cd crypt device handle
    ///
    /// @return path to underlying device name
    pub fn crypt_get_device_name(cd: *mut crypt_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get path to detached metadata device or @e NULL if it is not detached.
    ///
    /// @param cd crypt device handle
    ///
    /// @return path to underlying device name
    pub fn crypt_get_metadata_device_name(cd: *mut crypt_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get device offset in 512-bytes sectors where real data starts (on
    /// underlying device).
    ///
    /// @param cd crypt device handle
    ///
    /// @return device offset in sectors
    pub fn crypt_get_data_offset(cd: *mut crypt_device) -> u64;
}
extern "C" {
    /// Get IV offset in 512-bytes sectors (skip).
    ///
    /// @param cd crypt device handle
    ///
    /// @return IV offset
    pub fn crypt_get_iv_offset(cd: *mut crypt_device) -> u64;
}
extern "C" {
    /// Get size (in bytes) of volume key for crypt device.
    ///
    /// @param cd crypt device handle
    ///
    /// @return volume key size
    ///
    /// @note For LUKS2, this function can be used only if there is at least
    ///       one keyslot assigned to data segment.
    pub fn crypt_get_volume_key_size(cd: *mut crypt_device) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get size (in bytes) of encryption sector for crypt device.
    ///
    /// @param cd crypt device handle
    ///
    /// @return sector size
    pub fn crypt_get_sector_size(cd: *mut crypt_device) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Check if initialized LUKS context uses detached header
    /// (LUKS header located on a different device than data.)
    ///
    /// @param cd crypt device handle
    ///
    /// @return @e 1 if detached header is used, @e 0 if not
    /// or negative errno value otherwise.
    ///
    /// @note This is a runtime attribute, it does not say
    /// 	 if a LUKS device requires detached header.
    /// 	 This function works only with LUKS devices.
    pub fn crypt_header_is_detached(cd: *mut crypt_device) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get device parameters for VERITY device.
    ///
    /// @param cd crypt device handle
    /// @param vp verity device info
    ///
    /// @e 0 on success or negative errno value otherwise.
    pub fn crypt_get_verity_info(
        cd: *mut crypt_device,
        vp: *mut crypt_params_verity,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get device parameters for INTEGRITY device.
    ///
    /// @param cd crypt device handle
    /// @param ip verity device info
    ///
    /// @e 0 on success or negative errno value otherwise.
    pub fn crypt_get_integrity_info(
        cd: *mut crypt_device,
        ip: *mut crypt_params_integrity,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Informational benchmark for ciphers.
    ///
    /// @param cd crypt device handle
    /// @param cipher (e.g. "aes")
    /// @param cipher_mode (e.g. "xts"), IV generator is ignored
    /// @param volume_key_size size of volume key in bytes
    /// @param iv_size size of IV in bytes
    /// @param buffer_size size of encryption buffer in bytes used in test
    /// @param encryption_mbs measured encryption speed in MiB/s
    /// @param decryption_mbs measured decryption speed in MiB/s
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note If encryption_buffer_size is too small and encryption time
    ///       cannot be properly measured, -ERANGE is returned.
    pub fn crypt_benchmark(
        cd: *mut crypt_device,
        cipher: *const ::std::os::raw::c_char,
        cipher_mode: *const ::std::os::raw::c_char,
        volume_key_size: usize,
        iv_size: usize,
        buffer_size: usize,
        encryption_mbs: *mut f64,
        decryption_mbs: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Informational benchmark for PBKDF.
    ///
    /// @param cd crypt device handle
    /// @param pbkdf PBKDF parameters
    /// @param password password for benchmark
    /// @param password_size size of password
    /// @param salt salt for benchmark
    /// @param salt_size size of salt
    /// @param volume_key_size output volume key size
    /// @param progress callback function
    /// @param usrptr provided identification in callback
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_benchmark_pbkdf(
        cd: *mut crypt_device,
        pbkdf: *mut crypt_pbkdf_type,
        password: *const ::std::os::raw::c_char,
        password_size: usize,
        salt: *const ::std::os::raw::c_char,
        salt_size: usize,
        volume_key_size: usize,
        progress: ::std::option::Option<
            unsafe extern "C" fn(
                time_ms: u32,
                usrptr: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        usrptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
/// < invalid keyslot
pub const crypt_keyslot_info_CRYPT_SLOT_INVALID: crypt_keyslot_info = 0;
/// < keyslot is inactive (free)
pub const crypt_keyslot_info_CRYPT_SLOT_INACTIVE: crypt_keyslot_info = 1;
/// < keyslot is active (used)
pub const crypt_keyslot_info_CRYPT_SLOT_ACTIVE: crypt_keyslot_info = 2;
/// < keylost is active (used)
///  and last used at the same time
pub const crypt_keyslot_info_CRYPT_SLOT_ACTIVE_LAST: crypt_keyslot_info = 3;
/// < keyslot is active and not bound
///  to any crypt segment (LUKS2 only)
pub const crypt_keyslot_info_CRYPT_SLOT_UNBOUND: crypt_keyslot_info = 4;
/// Crypt keyslot info
pub type crypt_keyslot_info = ::std::os::raw::c_uint;
extern "C" {
    /// Get information about particular key slot.
    ///
    /// @param cd crypt device handle
    /// @param keyslot requested keyslot to check or CRYPT_ANY_SLOT
    ///
    /// @return value defined by crypt_keyslot_info
    pub fn crypt_keyslot_status(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
    ) -> crypt_keyslot_info;
}
/// < no such slot
pub const crypt_keyslot_priority_CRYPT_SLOT_PRIORITY_INVALID: crypt_keyslot_priority = -1;
/// < CRYPT_ANY_SLOT will ignore it for open
pub const crypt_keyslot_priority_CRYPT_SLOT_PRIORITY_IGNORE: crypt_keyslot_priority = 0;
/// < default priority, tried after preferred
pub const crypt_keyslot_priority_CRYPT_SLOT_PRIORITY_NORMAL: crypt_keyslot_priority = 1;
/// < will try to open first
pub const crypt_keyslot_priority_CRYPT_SLOT_PRIORITY_PREFER: crypt_keyslot_priority = 2;
/// Crypt keyslot priority
pub type crypt_keyslot_priority = ::std::os::raw::c_int;
extern "C" {
    /// Get keyslot priority (LUKS2)
    ///
    /// @param cd crypt device handle
    /// @param keyslot keyslot number
    ///
    /// @return value defined by crypt_keyslot_priority
    pub fn crypt_keyslot_get_priority(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
    ) -> crypt_keyslot_priority;
}
extern "C" {
    /// Set keyslot priority (LUKS2)
    ///
    /// @param cd crypt device handle
    /// @param keyslot keyslot number
    /// @param priority priority defined in crypt_keyslot_priority
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_keyslot_set_priority(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        priority: crypt_keyslot_priority,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get number of keyslots supported for device type.
    ///
    /// @param type crypt device type
    ///
    /// @return slot count or negative errno otherwise if device
    /// doesn't not support keyslots.
    pub fn crypt_keyslot_max(type_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get keyslot area pointers (relative to metadata device).
    ///
    /// @param cd crypt device handle
    /// @param keyslot keyslot number
    /// @param offset offset on metadata device (in bytes)
    /// @param length length of keyslot area (in bytes)
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_keyslot_area(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        offset: *mut u64,
        length: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get size (in bytes) of stored key in particular keyslot.
    /// Use for LUKS2 unbound keyslots, for other keyslots it is the same as
    /// @ref crypt_get_volume_key_size
    ///
    /// @param cd crypt device handle
    /// @param keyslot keyslot number
    ///
    /// @return volume key size or negative errno value otherwise.
    pub fn crypt_keyslot_get_key_size(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get cipher and key size for keyslot encryption.
    /// Use for LUKS2 keyslot to set different encryption type than for data
    /// encryption. Parameters will be used for next keyslot operations.
    ///
    /// @param cd crypt device handle
    /// @param keyslot keyslot number of CRYPT_ANY_SLOT for default
    /// @param key_size encryption key size (in bytes)
    ///
    /// @return cipher specification on success or @e NULL.
    ///
    /// @note This is the encryption of keyslot itself, not the data encryption
    /// algorithm!
    pub fn crypt_keyslot_get_encryption(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        key_size: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get PBKDF parameters for keyslot.
    ///
    /// @param cd crypt device handle
    /// @param keyslot keyslot number
    /// @param pbkdf struct with returned PBKDF parameters
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_keyslot_get_pbkdf(
        cd: *mut crypt_device,
        keyslot: ::std::os::raw::c_int,
        pbkdf: *mut crypt_pbkdf_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set encryption for keyslot.
    /// Use for LUKS2 keyslot to set different encryption type than for data
    /// encryption. Parameters will be used for next keyslot operations that
    /// create or change a keyslot.
    ///
    /// @param cd crypt device handle
    /// @param cipher (e.g. "aes-xts-plain64")
    /// @param key_size encryption key size (in bytes)
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note To reset to default keyslot encryption (the same as for data)
    ///       set cipher to NULL and key size to 0.
    pub fn crypt_keyslot_set_encryption(
        cd: *mut crypt_device,
        cipher: *const ::std::os::raw::c_char,
        key_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get directory where mapped crypt devices are created
    ///
    /// @return the directory path
    pub fn crypt_get_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// @defgroup crypt-backup Device metadata backup
    /// @addtogroup crypt-backup
    /// @{
    ////**
    /// Backup header and keyslots to file.
    ///
    /// @param cd crypt device handle
    /// @param requested_type @link crypt-type @endlink or @e NULL for all known
    /// @param backup_file file to backup header to
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_header_backup(
        cd: *mut crypt_device,
        requested_type: *const ::std::os::raw::c_char,
        backup_file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Restore header and keyslots from backup file.
    ///
    /// @param cd crypt device handle
    /// @param requested_type @link crypt-type @endlink or @e NULL for all known
    /// @param backup_file file to restore header from
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_header_restore(
        cd: *mut crypt_device,
        requested_type: *const ::std::os::raw::c_char,
        backup_file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set the debug level for library
    ///
    /// @param level debug level
    pub fn crypt_set_debug_level(level: ::std::os::raw::c_int);
}
extern "C" {
    /// Read keyfile
    ///
    /// @param cd crypt device handle
    /// @param keyfile keyfile to read
    /// @param key buffer for key
    /// @param key_size_read size of read key
    /// @param keyfile_offset key offset in keyfile
    /// @param key_size exact key length to read from file or 0
    /// @param flags keyfile read flags
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note If key_size is set to zero we read internal max length
    /// 	 and actual size read is returned via key_size_read parameter.
    pub fn crypt_keyfile_device_read(
        cd: *mut crypt_device,
        keyfile: *const ::std::os::raw::c_char,
        key: *mut *mut ::std::os::raw::c_char,
        key_size_read: *mut usize,
        keyfile_offset: u64,
        key_size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Backward compatible crypt_keyfile_device_read() (with size_t offset).
    pub fn crypt_keyfile_read(
        cd: *mut crypt_device,
        keyfile: *const ::std::os::raw::c_char,
        key: *mut *mut ::std::os::raw::c_char,
        key_size_read: *mut usize,
        keyfile_offset: usize,
        key_size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
/// < Fill with zeroes
pub const crypt_wipe_pattern_CRYPT_WIPE_ZERO: crypt_wipe_pattern = 0;
/// < Use RNG to fill data
pub const crypt_wipe_pattern_CRYPT_WIPE_RANDOM: crypt_wipe_pattern = 1;
/// < Obsolete, same as CRYPT_WIPE_RANDOM
pub const crypt_wipe_pattern_CRYPT_WIPE_ENCRYPTED_ZERO: crypt_wipe_pattern = 2;
/// < Compatibility only, do not use (Gutmann method)
pub const crypt_wipe_pattern_CRYPT_WIPE_SPECIAL: crypt_wipe_pattern = 3;
/// @defgroup crypt-wipe Function to wipe device
/// @addtogroup crypt-wipe
/// @{
////**
/// Wipe pattern
pub type crypt_wipe_pattern = ::std::os::raw::c_uint;
extern "C" {
    /// Wipe/Fill (part of) a device with the selected pattern.
    ///
    /// @param cd crypt device handle
    /// @param dev_path path to device to wipe or @e NULL if data device should
    /// be used @param pattern selected wipe pattern
    /// @param offset offset on device (in bytes)
    /// @param length length of area to be wiped (in bytes)
    /// @param wipe_block_size used block for wiping (one step) (in bytes)
    /// @param flags wipe flags
    /// @param progress callback function called after each @e wipe_block_size
    /// or @e NULL @param usrptr provided identification in callback
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note A @e progress callback can interrupt wipe process by returning
    /// non-zero code.
    ///
    /// @note If the error values is -EIO or -EINTR, some part of the device
    /// could       be overwritten. Other error codes (-EINVAL, -ENOMEM)
    /// means that no IO was performed.
    pub fn crypt_wipe(
        cd: *mut crypt_device,
        dev_path: *const ::std::os::raw::c_char,
        pattern: crypt_wipe_pattern,
        offset: u64,
        length: u64,
        wipe_block_size: usize,
        flags: u32,
        progress: ::std::option::Option<
            unsafe extern "C" fn(
                size: u64,
                offset: u64,
                usrptr: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        usrptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const CRYPT_LUKS2_SEGMENT: _bindgen_ty_1 = -2;
pub const CRYPT_NO_SEGMENT: _bindgen_ty_1 = -1;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
extern "C" {
    /// Safe erase of a partition or an entire OPAL device. WARNING: ALL DATA ON
    /// PARTITION/DISK WILL BE LOST. If the CRYPT_NO_SEGMENT is passed as the
    /// segment parameter, the entire device will be wiped, not just what is
    /// included in the LUKS2 device/partition.
    ///
    /// @param cd crypt device handle
    /// @param segment the segment number to wipe (0..8), or CRYPT_LUKS2_SEGMENT
    ///        to wipe the segment configured in the LUKS2 header, or
    /// CRYPT_NO_SEGMENT        to wipe the entire device via a factory
    /// reset. @param password admin password/PSID (for factory reset) to
    /// wipe the        partition/device
    /// @param password_size length of password/PSID
    /// @param flags (currently unused)
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_wipe_hw_opal(
        cd: *mut crypt_device,
        segment: ::std::os::raw::c_int,
        password: *const ::std::os::raw::c_char,
        password_size: usize,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get number of tokens supported for device type.
    ///
    /// @param type crypt device type
    ///
    /// @return token count or negative errno otherwise if device
    /// doesn't not support tokens.
    ///
    /// @note Real number of supported tokens for a particular device depends
    ///       on usable metadata area size.
    pub fn crypt_token_max(type_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get content of a token definition in JSON format.
    ///
    /// @param cd crypt device handle
    /// @param token token id
    /// @param json buffer with JSON
    ///
    /// @return allocated token id or negative errno otherwise.
    pub fn crypt_token_json_get(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        json: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Store content of a token definition in JSON format.
    ///
    /// @param cd crypt device handle
    /// @param token token id or @e CRYPT_ANY_TOKEN to allocate new one
    /// @param json buffer with JSON or @e NULL to remove token
    ///
    /// @return allocated token id or negative errno otherwise.
    ///
    /// @note The buffer must be in proper JSON format and must contain at least
    ///       string "type" with slot type and an array of string names
    /// "keyslots".       Keyslots array contains assignments to particular
    /// slots and can be empty.
    pub fn crypt_token_json_set(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        json: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
/// < token is invalid
pub const crypt_token_info_CRYPT_TOKEN_INVALID: crypt_token_info = 0;
/// < token is empty (free)
pub const crypt_token_info_CRYPT_TOKEN_INACTIVE: crypt_token_info = 1;
/// < active internal token with driver
pub const crypt_token_info_CRYPT_TOKEN_INTERNAL: crypt_token_info = 2;
/// < active internal token (reserved name) with missing token driver
pub const crypt_token_info_CRYPT_TOKEN_INTERNAL_UNKNOWN: crypt_token_info = 3;
/// < active external (user defined) token with driver
pub const crypt_token_info_CRYPT_TOKEN_EXTERNAL: crypt_token_info = 4;
/// < active external (user defined) token with missing token driver
pub const crypt_token_info_CRYPT_TOKEN_EXTERNAL_UNKNOWN: crypt_token_info = 5;
/// Token info
pub type crypt_token_info = ::std::os::raw::c_uint;
extern "C" {
    /// Get info for specific token.
    ///
    /// @param cd crypt device handle
    /// @param token existing token id
    /// @param type pointer for returned type string
    ///
    /// @return token status info. For any returned status (besides
    /// CRYPT_TOKEN_INVALID 	   and CRYPT_TOKEN_INACTIVE) and if type
    /// parameter is not NULL it will 	   contain address of type string.
    ///
    /// @note if required, create a copy of string referenced in *type before
    /// calling next 	 libcryptsetup API function. The reference may become
    /// invalid.
    pub fn crypt_token_status(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        type_: *mut *const ::std::os::raw::c_char,
    ) -> crypt_token_info;
}
/// LUKS2 keyring token parameters.
///
/// @see crypt_token_builtin_set
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_token_params_luks2_keyring {
    /// < Reference in keyring
    pub key_description: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_token_params_luks2_keyring"]
        [::std::mem::size_of::<crypt_token_params_luks2_keyring>() - 8usize];
    ["Alignment of crypt_token_params_luks2_keyring"]
        [::std::mem::align_of::<crypt_token_params_luks2_keyring>() - 8usize];
    ["Offset of field: crypt_token_params_luks2_keyring::key_description"]
        [::std::mem::offset_of!(crypt_token_params_luks2_keyring, key_description) - 0usize];
};
extern "C" {
    /// Create a new luks2 keyring token.
    ///
    /// @param cd crypt device handle
    /// @param token token id or @e CRYPT_ANY_TOKEN to allocate new one
    /// @param params luks2 keyring token params
    ///
    /// @return allocated token id or negative errno otherwise.
    pub fn crypt_token_luks2_keyring_set(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        params: *const crypt_token_params_luks2_keyring,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get LUKS2 keyring token params
    ///
    /// @param cd crypt device handle
    /// @param token existing luks2 keyring token id
    /// @param params returned luks2 keyring token params
    ///
    /// @return allocated token id or negative errno otherwise.
    ///
    /// @note do not call free() on params members. Members are valid only
    /// 	 until next libcryptsetup function is called.
    pub fn crypt_token_luks2_keyring_get(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        params: *mut crypt_token_params_luks2_keyring,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Assign a token to particular keyslot.
    /// (There can be more keyslots assigned to one token id.)
    ///
    /// @param cd crypt device handle
    /// @param token token id
    /// @param keyslot keyslot to be assigned to token (CRYPT_ANY SLOT
    /// 	  assigns all active keyslots to token)
    ///
    /// @return allocated token id or negative errno otherwise.
    pub fn crypt_token_assign_keyslot(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        keyslot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Unassign a token from particular keyslot.
    /// (There can be more keyslots assigned to one token id.)
    ///
    /// @param cd crypt device handle
    /// @param token token id
    /// @param keyslot keyslot to be unassigned from token (CRYPT_ANY SLOT
    /// 	  unassigns all active keyslots from token)
    ///
    /// @return allocated token id or negative errno otherwise.
    pub fn crypt_token_unassign_keyslot(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        keyslot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get info about token assignment to particular keyslot.
    ///
    /// @param cd crypt device handle
    /// @param token token id
    /// @param keyslot keyslot
    ///
    /// @return 0 on success (token exists and is assigned to the keyslot),
    /// 	   -ENOENT if token is not assigned to a keyslot (token, keyslot
    /// 	   or both may be inactive) or other negative errno otherwise.
    pub fn crypt_token_is_assigned(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        keyslot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
/// Token handler open function prototype.
/// This function retrieves password from a token and return allocated buffer
/// containing this password. This buffer has to be deallocated by calling
/// free() function and content should be wiped before deallocation.
///
/// @param cd crypt device handle
/// @param token token id
/// @param buffer returned allocated buffer with password
/// @param buffer_len length of the buffer
/// @param usrptr user data in @link crypt_activate_by_token @endlink
///
/// @return 0 on success (token passed LUKS2 keyslot passphrase in buffer) or
///         negative errno otherwise.
///
/// @note Negative ENOANO errno means that token is PIN protected and caller
/// should       use @link crypt_activate_by_token_pin @endlink with PIN
/// provided.
///
/// @note Negative EAGAIN errno means token handler requires additional hardware
///       not present in the system.
pub type crypt_token_open_func = ::std::option::Option<
    unsafe extern "C" fn(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        buffer: *mut *mut ::std::os::raw::c_char,
        buffer_len: *mut usize,
        usrptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
/// Token handler open with passphrase/PIN function prototype.
/// This function retrieves password from a token and return allocated buffer
/// containing this password. This buffer has to be deallocated by calling
/// free() function and content should be wiped before deallocation.
///
/// @param cd crypt device handle
/// @param token token id
/// @param pin passphrase (or PIN) to unlock token (may be binary data)
/// @param pin_size size of @e pin
/// @param buffer returned allocated buffer with password
/// @param buffer_len length of the buffer
/// @param usrptr user data in @link crypt_activate_by_token @endlink
///
/// @return 0 on success (token passed LUKS2 keyslot passphrase in buffer) or
///         negative errno otherwise.
///
/// @note Negative ENOANO errno means that token is PIN protected and PIN was
///       missing or wrong.
///
/// @note Negative EAGAIN errno means token handler requires additional hardware
///       not present in the system.
pub type crypt_token_open_pin_func = ::std::option::Option<
    unsafe extern "C" fn(
        cd: *mut crypt_device,
        token: ::std::os::raw::c_int,
        pin: *const ::std::os::raw::c_char,
        pin_size: usize,
        buffer: *mut *mut ::std::os::raw::c_char,
        buffer_len: *mut usize,
        usrptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
/// Token handler buffer free function prototype.
/// This function is used by library to free the buffer with keyslot
/// passphrase when it's no longer needed. If not defined the library
/// overwrites buffer with zeroes and call free().
///
/// @param buffer the buffer with keyslot passphrase
/// @param buffer_len the buffer length
pub type crypt_token_buffer_free_func = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut ::std::os::raw::c_void, buffer_len: usize),
>;
/// Token handler validate function prototype.
/// This function validates JSON representation of user defined token for
/// additional data specific for its token type. If defined in the handler, it's
/// called during @link crypt_activate_by_token @endlink. It may also be called
/// during @link crypt_token_json_set @endlink when appropriate token handler
/// was registered before with @link crypt_token_register @endlink.
///
/// @param cd crypt device handle
/// @param json buffer with JSON
pub type crypt_token_validate_func = ::std::option::Option<
    unsafe extern "C" fn(
        cd: *mut crypt_device,
        json: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
/// Token handler dump function prototype.
/// This function is supposed to print token implementation specific details. It
/// gets called during @link crypt_dump @endlink if token handler was registered
/// before.
///
/// @param cd crypt device handle
/// @param json buffer with token JSON
///
/// @note dump implementations are advised to use @link crypt_log @endlink
/// function 	 to dump token details.
pub type crypt_token_dump_func = ::std::option::Option<
    unsafe extern "C" fn(cd: *mut crypt_device, json: *const ::std::os::raw::c_char),
>;
/// Token handler version function prototype.
/// This function is supposed to return pointer to version string information.
///
/// @note The returned string is advised to contain only version.
/// 	 For example '1.0.0' or 'v1.2.3.4'.
pub type crypt_token_version_func =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
/// Token handler
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_token_handler {
    /// < token handler name
    pub name: *const ::std::os::raw::c_char,
    /// < token handler open function
    pub open: crypt_token_open_func,
    /// < token handler buffer_free function (optional)
    pub buffer_free: crypt_token_buffer_free_func,
    /// < token handler validate function (optional)
    pub validate: crypt_token_validate_func,
    /// < token handler dump function (optional)
    pub dump: crypt_token_dump_func,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_token_handler"][::std::mem::size_of::<crypt_token_handler>() - 40usize];
    ["Alignment of crypt_token_handler"][::std::mem::align_of::<crypt_token_handler>() - 8usize];
    ["Offset of field: crypt_token_handler::name"]
        [::std::mem::offset_of!(crypt_token_handler, name) - 0usize];
    ["Offset of field: crypt_token_handler::open"]
        [::std::mem::offset_of!(crypt_token_handler, open) - 8usize];
    ["Offset of field: crypt_token_handler::buffer_free"]
        [::std::mem::offset_of!(crypt_token_handler, buffer_free) - 16usize];
    ["Offset of field: crypt_token_handler::validate"]
        [::std::mem::offset_of!(crypt_token_handler, validate) - 24usize];
    ["Offset of field: crypt_token_handler::dump"]
        [::std::mem::offset_of!(crypt_token_handler, dump) - 32usize];
};
extern "C" {
    /// Register token handler
    ///
    /// @param handler token handler to register
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_token_register(handler: *const crypt_token_handler) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Report configured path where library searches for external token
    /// handlers
    ///
    /// @return @e absolute path when external tokens are enabled or @e NULL
    /// otherwise.
    pub fn crypt_token_external_path() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Override configured external token handlers path for the library.
    ///
    /// @param path Absolute path (starts with '/') to new external token
    /// handlers directory or @e NULL.
    ///
    /// @note if @e path is @e NULL the external token path is reset to default
    /// path.
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    pub fn crypt_token_set_external_path(
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Disable external token handlers (plugins) support
    /// If disabled, it cannot be enabled again.
    pub fn crypt_token_external_disable();
}
extern "C" {
    /// Activate device or check key using a token.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to create, if @e NULL only check token
    /// @param token requested token to check or CRYPT_ANY_TOKEN to check all
    /// @param usrptr provided identification in callback
    /// @param flags activation flags
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    ///
    /// @note EPERM errno means token provided passphrase successfully, but
    ///       passphrase did not unlock any keyslot associated with the token.
    ///
    /// @note ENOENT errno means no token (or subsequently assigned keyslot) was
    ///       eligible to unlock device.
    ///
    /// @note ENOANO errno means that token is PIN protected and you should call
    ///       @link crypt_activate_by_token_pin @endlink with PIN
    ///
    /// @note Negative EAGAIN errno means token handler requires additional
    /// hardware       not present in the system.
    ///
    /// @note with @e token set to CRYPT_ANY_TOKEN libcryptsetup runs best
    /// effort loop       to unlock device using any available token. It may
    /// happen that various token handlers       return different error
    /// codes. At the end loop returns error codes in the following
    ///       order (from the most significant to the least) any negative errno
    /// except those       listed below, non negative token id (success),
    /// -ENOANO, -EAGAIN, -EPERM, -ENOENT.
    pub fn crypt_activate_by_token(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        token: ::std::os::raw::c_int,
        usrptr: *mut ::std::os::raw::c_void,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Activate device or check key using a token with PIN.
    ///
    /// @param cd crypt device handle
    /// @param name name of device to create, if @e NULL only check token
    /// @param type restrict type of token, if @e NULL all types are allowed
    /// @param token requested token to check or CRYPT_ANY_TOKEN to check all
    /// @param pin passphrase (or PIN) to unlock token (may be binary data)
    /// @param pin_size size of @e pin
    /// @param usrptr provided identification in callback
    /// @param flags activation flags
    ///
    /// @return unlocked key slot number or negative errno otherwise.
    ///
    /// @note EPERM errno means token provided passphrase successfully, but
    ///       passphrase did not unlock any keyslot associated with the token.
    ///
    /// @note ENOENT errno means no token (or subsequently assigned keyslot) was
    ///       eligible to unlock device.
    ///
    /// @note ENOANO errno means that token is PIN protected and was either
    /// missing       (NULL) or wrong.
    ///
    /// @note Negative EAGAIN errno means token handler requires additional
    /// hardware       not present in the system.
    ///
    /// @note with @e token set to CRYPT_ANY_TOKEN libcryptsetup runs best
    /// effort loop       to unlock device using any available token. It may
    /// happen that various token handlers       return different error
    /// codes. At the end loop returns error codes in the following
    ///       order (from the most significant to the least) any negative errno
    /// except those       listed below, non negative token id (success),
    /// -ENOANO, -EAGAIN, -EPERM, -ENOENT.
    pub fn crypt_activate_by_token_pin(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        token: ::std::os::raw::c_int,
        pin: *const ::std::os::raw::c_char,
        pin_size: usize,
        usrptr: *mut ::std::os::raw::c_void,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
/// < forward direction
pub const crypt_reencrypt_direction_info_CRYPT_REENCRYPT_FORWARD: crypt_reencrypt_direction_info =
    0;
/// < backward direction
pub const crypt_reencrypt_direction_info_CRYPT_REENCRYPT_BACKWARD: crypt_reencrypt_direction_info =
    1;
/// Reencryption direction
pub type crypt_reencrypt_direction_info = ::std::os::raw::c_uint;
/// < Reencryption mode
pub const crypt_reencrypt_mode_info_CRYPT_REENCRYPT_REENCRYPT: crypt_reencrypt_mode_info = 0;
/// < Encryption mode
pub const crypt_reencrypt_mode_info_CRYPT_REENCRYPT_ENCRYPT: crypt_reencrypt_mode_info = 1;
/// < Decryption mode
pub const crypt_reencrypt_mode_info_CRYPT_REENCRYPT_DECRYPT: crypt_reencrypt_mode_info = 2;
/// Reencryption mode
pub type crypt_reencrypt_mode_info = ::std::os::raw::c_uint;
/// LUKS2 reencryption options.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_params_reencrypt {
    /// < Reencryption mode, immutable after first init.
    pub mode: crypt_reencrypt_mode_info,
    /// < Reencryption direction, immutable after first init.
    pub direction: crypt_reencrypt_direction_info,
    /// < Resilience mode: "none", "checksum", "journal", "datashift",
    /// "datashift-checksum" or "datashift-journal".
    /// "datashift" mode is immutable, "datashift-" subvariant can be only
    /// changed to other "datashift-" subvariant
    pub resilience: *const ::std::os::raw::c_char,
    /// < Used hash for "checksum" resilience type, ignored otherwise.
    pub hash: *const ::std::os::raw::c_char,
    /// < Used in "datashift" mode (and subvariants), must be non-zero,
    /// immutable after first init.
    pub data_shift: u64,
    /// < Maximum hotzone size (may be lowered by library). For "datashift-"
    /// subvariants it is used to set size of moved segment (decryption
    /// only).
    pub max_hotzone_size: u64,
    /// < Reencrypt only initial part of the data device.
    pub device_size: u64,
    /// < LUKS2 parameters for the final reencryption volume.
    pub luks2: *const crypt_params_luks2,
    /// < Reencryption flags.
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of crypt_params_reencrypt"][::std::mem::size_of::<crypt_params_reencrypt>() - 64usize];
    ["Alignment of crypt_params_reencrypt"]
        [::std::mem::align_of::<crypt_params_reencrypt>() - 8usize];
    ["Offset of field: crypt_params_reencrypt::mode"]
        [::std::mem::offset_of!(crypt_params_reencrypt, mode) - 0usize];
    ["Offset of field: crypt_params_reencrypt::direction"]
        [::std::mem::offset_of!(crypt_params_reencrypt, direction) - 4usize];
    ["Offset of field: crypt_params_reencrypt::resilience"]
        [::std::mem::offset_of!(crypt_params_reencrypt, resilience) - 8usize];
    ["Offset of field: crypt_params_reencrypt::hash"]
        [::std::mem::offset_of!(crypt_params_reencrypt, hash) - 16usize];
    ["Offset of field: crypt_params_reencrypt::data_shift"]
        [::std::mem::offset_of!(crypt_params_reencrypt, data_shift) - 24usize];
    ["Offset of field: crypt_params_reencrypt::max_hotzone_size"]
        [::std::mem::offset_of!(crypt_params_reencrypt, max_hotzone_size) - 32usize];
    ["Offset of field: crypt_params_reencrypt::device_size"]
        [::std::mem::offset_of!(crypt_params_reencrypt, device_size) - 40usize];
    ["Offset of field: crypt_params_reencrypt::luks2"]
        [::std::mem::offset_of!(crypt_params_reencrypt, luks2) - 48usize];
    ["Offset of field: crypt_params_reencrypt::flags"]
        [::std::mem::offset_of!(crypt_params_reencrypt, flags) - 56usize];
};
extern "C" {
    /// Initialize reencryption metadata using passphrase.
    ///
    /// This function initializes on-disk metadata to include all reencryption
    /// segments, according to the provided options.
    /// If metadata already contains ongoing reencryption metadata, it loads
    /// these parameters (in this situation all parameters except @e name
    /// and @e passphrase can be omitted).
    ///
    /// @param cd crypt device handle
    /// @param name name of active device or @e NULL for offline reencryption
    /// @param passphrase passphrase used to unlock volume key
    /// @param passphrase_size size of @e passphrase (binary data)
    /// @param keyslot_old keyslot to unlock existing device or CRYPT_ANY_SLOT
    /// @param keyslot_new existing (unbound) reencryption keyslot; must be set
    /// except for decryption @param cipher cipher specification (e.g.
    /// "aes") @param cipher_mode cipher mode and IV (e.g. "xts-plain64")
    /// @param params reencryption parameters @link crypt_params_reencrypt
    /// @endlink.
    ///
    /// @return reencryption key slot number or negative errno otherwise.
    pub fn crypt_reencrypt_init_by_passphrase(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        passphrase: *const ::std::os::raw::c_char,
        passphrase_size: usize,
        keyslot_old: ::std::os::raw::c_int,
        keyslot_new: ::std::os::raw::c_int,
        cipher: *const ::std::os::raw::c_char,
        cipher_mode: *const ::std::os::raw::c_char,
        params: *const crypt_params_reencrypt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Initialize reencryption metadata using passphrase in keyring.
    ///
    /// This function initializes on-disk metadata to include all reencryption
    /// segments, according to the provided options.
    /// If metadata already contains ongoing reencryption metadata, it loads
    /// these parameters (in this situation all parameters except @e name
    /// and @e key_description can be omitted).
    ///
    /// @param cd crypt device handle
    /// @param name name of active device or @e NULL for offline reencryption
    /// @param key_description passphrase (key) identification in keyring
    /// @param keyslot_old keyslot to unlock existing device or CRYPT_ANY_SLOT
    /// @param keyslot_new existing (unbound) reencryption keyslot; must be set
    /// except for decryption @param cipher cipher specification (e.g.
    /// "aes") @param cipher_mode cipher mode and IV (e.g. "xts-plain64")
    /// @param params reencryption parameters @link crypt_params_reencrypt
    /// @endlink.
    ///
    /// @return reencryption key slot number or negative errno otherwise.
    pub fn crypt_reencrypt_init_by_keyring(
        cd: *mut crypt_device,
        name: *const ::std::os::raw::c_char,
        key_description: *const ::std::os::raw::c_char,
        keyslot_old: ::std::os::raw::c_int,
        keyslot_new: ::std::os::raw::c_int,
        cipher: *const ::std::os::raw::c_char,
        cipher_mode: *const ::std::os::raw::c_char,
        params: *const crypt_params_reencrypt,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Legacy data reencryption function.
    ///
    /// @param cd crypt device handle
    /// @param progress is a callback function reporting device \b size,
    /// current \b offset of reencryption and provided \b usrptr identification
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @deprecated Use @link crypt_reencrypt_run @endlink instead.
    pub fn crypt_reencrypt(
        cd: *mut crypt_device,
        progress: ::std::option::Option<
            unsafe extern "C" fn(
                size: u64,
                offset: u64,
                usrptr: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Run data reencryption.
    ///
    /// @param cd crypt device handle
    /// @param progress is a callback function reporting device \b size,
    /// current \b offset of reencryption and provided \b usrptr identification
    /// @param usrptr progress specific data
    ///
    /// @return @e 0 on success or negative errno value otherwise.
    ///
    /// @note A @e progress callback can interrupt reencryption process by
    /// returning non-zero code.
    pub fn crypt_reencrypt_run(
        cd: *mut crypt_device,
        progress: ::std::option::Option<
            unsafe extern "C" fn(
                size: u64,
                offset: u64,
                usrptr: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        usrptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
/// < No reencryption in progress
pub const crypt_reencrypt_info_CRYPT_REENCRYPT_NONE: crypt_reencrypt_info = 0;
/// < Ongoing reencryption in a clean state.
pub const crypt_reencrypt_info_CRYPT_REENCRYPT_CLEAN: crypt_reencrypt_info = 1;
/// < Aborted reencryption that need internal recovery.
pub const crypt_reencrypt_info_CRYPT_REENCRYPT_CRASH: crypt_reencrypt_info = 2;
/// < Invalid state.
pub const crypt_reencrypt_info_CRYPT_REENCRYPT_INVALID: crypt_reencrypt_info = 3;
/// Reencryption status info
pub type crypt_reencrypt_info = ::std::os::raw::c_uint;
extern "C" {
    /// LUKS2 reencryption status.
    ///
    /// @param cd crypt device handle
    /// @param params reencryption parameters
    ///
    /// @return reencryption status info and parameters.
    pub fn crypt_reencrypt_status(
        cd: *mut crypt_device,
        params: *mut crypt_params_reencrypt,
    ) -> crypt_reencrypt_info;
}
extern "C" {
    /// Allocate safe memory (content is safely wiped on deallocation).
    ///
    /// @param size size of memory in bytes
    ///
    /// @return pointer to allocated memory or @e NULL.
    pub fn crypt_safe_alloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Release safe memory, content is safely wiped.
    /// The pointer must be allocated with @link crypt_safe_alloc @endlink
    ///
    /// @param data pointer to memory to be deallocated
    pub fn crypt_safe_free(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Reallocate safe memory (content is copied and safely wiped on
    /// deallocation).
    ///
    /// @param data pointer to memory to be deallocated
    /// @param size new size of memory in bytes
    ///
    /// @return pointer to allocated memory or @e NULL.
    pub fn crypt_safe_realloc(
        data: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Safe clear memory area (compile should not compile this call out).
    ///
    /// @param data pointer to memory to be cleared
    /// @param size size of memory in bytes
    pub fn crypt_safe_memzero(data: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    /// Link the volume key to the specified kernel keyring.
    ///
    /// The volume can have one or two keys. Normally, the device has one key.
    /// However if reencryption was started and not finished yet, the volume
    /// will have two volume keys (the new VK for the already reencrypted
    /// segment and old VK for the not yet reencrypted segment).
    ///
    /// The @e old_key_description argument is required only for
    /// devices that are in re-encryption and have two volume keys at the same
    /// time (old and new). You can set the @e old_key_description to NULL,
    /// but if you supply number of keys less than required, the function will
    /// return -ESRCH.  In that case you need to call the function again and set
    /// the missing key description. When supplying just one key description,
    /// make sure to supply it in the @e key_description.
    ///
    /// @param cd crypt device handle
    /// @param key_description the key description of the volume key linked in
    /// desired keyring. @param old_key_description the key description of
    /// the old volume key linked in desired keyring 	  (for devices in
    /// re-encryption). @param key_type_desc the key type used for the
    /// volume key. Currently only "user" and "logon" types are
    /// 	  supported. if @e NULL is specified the default "user" type is
    /// applied. @param keyring_to_link_vk the keyring description of the
    /// keyring in which volume key should 	  be linked, if @e NULL is
    /// specified, linking will be disabled.
    ///
    /// @note keyring_to_link_vk may be passed in various string formats:
    /// 	 It can be kernel key numeric id of existing keyring written as a
    /// string, 	 keyring name prefixed by either "%:" or "%keyring:"
    /// substrings or keyctl 	 special values for keyrings "@t", "@p", "@s"
    /// and so on. See keyctl(1) man page, 	 section KEY IDENTIFIERS for
    /// more information. All other prefixes starting "%<type>:"
    /// 	 are ignored.
    ///
    /// @note key_description "%<type>:" prefixes are ignored. Type is applied
    /// based on key_type parameter 	 value.
    pub fn crypt_set_keyring_to_link(
        cd: *mut crypt_device,
        key_description: *const ::std::os::raw::c_char,
        old_key_description: *const ::std::os::raw::c_char,
        key_type_desc: *const ::std::os::raw::c_char,
        keyring_to_link_vk: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
